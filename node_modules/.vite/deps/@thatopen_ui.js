import "./chunk-HKJ2B2AA.js";

// node_modules/@thatopen/ui/dist/index.js
var Xs = Object.defineProperty;
var Zs = (s, t, e) => t in s ? Xs(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e;
var ut = (s, t, e) => (Zs(s, typeof t != "symbol" ? t + "" : t, e), e);
var Ht = Math.min;
var st = Math.max;
var ke = Math.round;
var pt = (s) => ({
  x: s,
  y: s
});
var Js = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var tr = {
  start: "end",
  end: "start"
};
function pn(s, t, e) {
  return st(s, Ht(t, e));
}
function pe(s, t) {
  return typeof s == "function" ? s(t) : s;
}
function rt(s) {
  return s.split("-")[0];
}
function Fe(s) {
  return s.split("-")[1];
}
function Jn(s) {
  return s === "x" ? "y" : "x";
}
function ts(s) {
  return s === "y" ? "height" : "width";
}
var er = /* @__PURE__ */ new Set(["top", "bottom"]);
function nt(s) {
  return er.has(rt(s)) ? "y" : "x";
}
function es(s) {
  return Jn(nt(s));
}
function ir(s, t, e) {
  e === void 0 && (e = false);
  const i = Fe(s), n = es(s), r = ts(n);
  let o = n === "x" ? i === (e ? "end" : "start") ? "right" : "left" : i === "start" ? "bottom" : "top";
  return t.reference[r] > t.floating[r] && (o = Pe(o)), [o, Pe(o)];
}
function nr(s) {
  const t = Pe(s);
  return [li(s), t, li(t)];
}
function li(s) {
  return s.replace(/start|end/g, (t) => tr[t]);
}
var fn = ["left", "right"];
var mn = ["right", "left"];
var sr = ["top", "bottom"];
var rr = ["bottom", "top"];
function or(s, t, e) {
  switch (s) {
    case "top":
    case "bottom":
      return e ? t ? mn : fn : t ? fn : mn;
    case "left":
    case "right":
      return t ? sr : rr;
    default:
      return [];
  }
}
function ar(s, t, e, i) {
  const n = Fe(s);
  let r = or(rt(s), e === "start", i);
  return n && (r = r.map((o) => o + "-" + n), t && (r = r.concat(r.map(li)))), r;
}
function Pe(s) {
  return s.replace(/left|right|bottom|top/g, (t) => Js[t]);
}
function lr(s) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...s
  };
}
function is(s) {
  return typeof s != "number" ? lr(s) : {
    top: s,
    right: s,
    bottom: s,
    left: s
  };
}
function Ft(s) {
  const {
    x: t,
    y: e,
    width: i,
    height: n
  } = s;
  return {
    width: i,
    height: n,
    top: e,
    left: t,
    right: t + i,
    bottom: e + n,
    x: t,
    y: e
  };
}
function bn(s, t, e) {
  let {
    reference: i,
    floating: n
  } = s;
  const r = nt(t), o = es(t), a = ts(o), l = rt(t), c = r === "y", u = i.x + i.width / 2 - n.width / 2, h = i.y + i.height / 2 - n.height / 2, p = i[a] / 2 - n[a] / 2;
  let m;
  switch (l) {
    case "top":
      m = {
        x: u,
        y: i.y - n.height
      };
      break;
    case "bottom":
      m = {
        x: u,
        y: i.y + i.height
      };
      break;
    case "right":
      m = {
        x: i.x + i.width,
        y: h
      };
      break;
    case "left":
      m = {
        x: i.x - n.width,
        y: h
      };
      break;
    default:
      m = {
        x: i.x,
        y: i.y
      };
  }
  switch (Fe(t)) {
    case "start":
      m[o] -= p * (e && c ? -1 : 1);
      break;
    case "end":
      m[o] += p * (e && c ? -1 : 1);
      break;
  }
  return m;
}
var cr = async (s, t, e) => {
  const {
    placement: i = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: o
  } = e, a = r.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(t));
  let c = await o.getElementRects({
    reference: s,
    floating: t,
    strategy: n
  }), {
    x: u,
    y: h
  } = bn(c, i, l), p = i, m = {}, g = 0;
  for (let v = 0; v < a.length; v++) {
    const {
      name: b,
      fn: w
    } = a[v], {
      x: y,
      y: x,
      data: A,
      reset: P
    } = await w({
      x: u,
      y: h,
      initialPlacement: i,
      placement: p,
      strategy: n,
      middlewareData: m,
      rects: c,
      platform: o,
      elements: {
        reference: s,
        floating: t
      }
    });
    u = y ?? u, h = x ?? h, m = {
      ...m,
      [b]: {
        ...m[b],
        ...A
      }
    }, P && g <= 50 && (g++, typeof P == "object" && (P.placement && (p = P.placement), P.rects && (c = P.rects === true ? await o.getElementRects({
      reference: s,
      floating: t,
      strategy: n
    }) : P.rects), {
      x: u,
      y: h
    } = bn(c, p, l)), v = -1);
  }
  return {
    x: u,
    y: h,
    placement: p,
    strategy: n,
    middlewareData: m
  };
};
async function ns(s, t) {
  var e;
  t === void 0 && (t = {});
  const {
    x: i,
    y: n,
    platform: r,
    rects: o,
    elements: a,
    strategy: l
  } = s, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: h = "floating",
    altBoundary: p = false,
    padding: m = 0
  } = pe(t, s), g = is(m), b = a[p ? h === "floating" ? "reference" : "floating" : h], w = Ft(await r.getClippingRect({
    element: (e = await (r.isElement == null ? void 0 : r.isElement(b))) == null || e ? b : b.contextElement || await (r.getDocumentElement == null ? void 0 : r.getDocumentElement(a.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: l
  })), y = h === "floating" ? {
    x: i,
    y: n,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, x = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(a.floating)), A = await (r.isElement == null ? void 0 : r.isElement(x)) ? await (r.getScale == null ? void 0 : r.getScale(x)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, P = Ft(r.convertOffsetParentRelativeRectToViewportRelativeRect ? await r.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: y,
    offsetParent: x,
    strategy: l
  }) : y);
  return {
    top: (w.top - P.top + g.top) / A.y,
    bottom: (P.bottom - w.bottom + g.bottom) / A.y,
    left: (w.left - P.left + g.left) / A.x,
    right: (P.right - w.right + g.right) / A.x
  };
}
var ur = function(s) {
  return s === void 0 && (s = {}), {
    name: "flip",
    options: s,
    async fn(t) {
      var e, i;
      const {
        placement: n,
        middlewareData: r,
        rects: o,
        initialPlacement: a,
        platform: l,
        elements: c
      } = t, {
        mainAxis: u = true,
        crossAxis: h = true,
        fallbackPlacements: p,
        fallbackStrategy: m = "bestFit",
        fallbackAxisSideDirection: g = "none",
        flipAlignment: v = true,
        ...b
      } = pe(s, t);
      if ((e = r.arrow) != null && e.alignmentOffset)
        return {};
      const w = rt(n), y = nt(a), x = rt(a) === a, A = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), P = p || (x || !v ? [Pe(a)] : nr(a)), $ = g !== "none";
      !p && $ && P.push(...ar(a, v, g, A));
      const L = [a, ...P], U = await ns(t, b), W = [];
      let k = ((i = r.flip) == null ? void 0 : i.overflows) || [];
      if (u && W.push(U[w]), h) {
        const K = ir(n, o, A);
        W.push(U[K[0]], U[K[1]]);
      }
      if (k = [...k, {
        placement: n,
        overflows: W
      }], !W.every((K) => K <= 0)) {
        var zt, Kt;
        const K = (((zt = r.flip) == null ? void 0 : zt.index) || 0) + 1, Ct = L[K];
        if (Ct && (!(h === "alignment" ? y !== nt(Ct) : false) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        k.every((j) => nt(j.placement) === y ? j.overflows[0] > 0 : true)))
          return {
            data: {
              index: K,
              overflows: k
            },
            reset: {
              placement: Ct
            }
          };
        let lt = (Kt = k.filter((it) => it.overflows[0] <= 0).sort((it, j) => it.overflows[1] - j.overflows[1])[0]) == null ? void 0 : Kt.placement;
        if (!lt)
          switch (m) {
            case "bestFit": {
              var Bt;
              const it = (Bt = k.filter((j) => {
                if ($) {
                  const ct = nt(j.placement);
                  return ct === y || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  ct === "y";
                }
                return true;
              }).map((j) => [j.placement, j.overflows.filter((ct) => ct > 0).reduce((ct, Ks) => ct + Ks, 0)]).sort((j, ct) => j[1] - ct[1])[0]) == null ? void 0 : Bt[0];
              it && (lt = it);
              break;
            }
            case "initialPlacement":
              lt = a;
              break;
          }
        if (n !== lt)
          return {
            reset: {
              placement: lt
            }
          };
      }
      return {};
    }
  };
};
function ss(s) {
  const t = Ht(...s.map((r) => r.left)), e = Ht(...s.map((r) => r.top)), i = st(...s.map((r) => r.right)), n = st(...s.map((r) => r.bottom));
  return {
    x: t,
    y: e,
    width: i - t,
    height: n - e
  };
}
function hr(s) {
  const t = s.slice().sort((n, r) => n.y - r.y), e = [];
  let i = null;
  for (let n = 0; n < t.length; n++) {
    const r = t[n];
    !i || r.y - i.y > i.height / 2 ? e.push([r]) : e[e.length - 1].push(r), i = r;
  }
  return e.map((n) => Ft(ss(n)));
}
var dr = function(s) {
  return s === void 0 && (s = {}), {
    name: "inline",
    options: s,
    async fn(t) {
      const {
        placement: e,
        elements: i,
        rects: n,
        platform: r,
        strategy: o
      } = t, {
        padding: a = 2,
        x: l,
        y: c
      } = pe(s, t), u = Array.from(await (r.getClientRects == null ? void 0 : r.getClientRects(i.reference)) || []), h = hr(u), p = Ft(ss(u)), m = is(a);
      function g() {
        if (h.length === 2 && h[0].left > h[1].right && l != null && c != null)
          return h.find((b) => l > b.left - m.left && l < b.right + m.right && c > b.top - m.top && c < b.bottom + m.bottom) || p;
        if (h.length >= 2) {
          if (nt(e) === "y") {
            const k = h[0], zt = h[h.length - 1], Kt = rt(e) === "top", Bt = k.top, K = zt.bottom, Ct = Kt ? k.left : zt.left, lt = Kt ? k.right : zt.right, it = lt - Ct, j = K - Bt;
            return {
              top: Bt,
              bottom: K,
              left: Ct,
              right: lt,
              width: it,
              height: j,
              x: Ct,
              y: Bt
            };
          }
          const b = rt(e) === "left", w = st(...h.map((k) => k.right)), y = Ht(...h.map((k) => k.left)), x = h.filter((k) => b ? k.left === y : k.right === w), A = x[0].top, P = x[x.length - 1].bottom, $ = y, L = w, U = L - $, W = P - A;
          return {
            top: A,
            bottom: P,
            left: $,
            right: L,
            width: U,
            height: W,
            x: $,
            y: A
          };
        }
        return p;
      }
      const v = await r.getElementRects({
        reference: {
          getBoundingClientRect: g
        },
        floating: i.floating,
        strategy: o
      });
      return n.reference.x !== v.reference.x || n.reference.y !== v.reference.y || n.reference.width !== v.reference.width || n.reference.height !== v.reference.height ? {
        reset: {
          rects: v
        }
      } : {};
    }
  };
};
var pr = /* @__PURE__ */ new Set(["left", "top"]);
async function fr(s, t) {
  const {
    placement: e,
    platform: i,
    elements: n
  } = s, r = await (i.isRTL == null ? void 0 : i.isRTL(n.floating)), o = rt(e), a = Fe(e), l = nt(e) === "y", c = pr.has(o) ? -1 : 1, u = r && l ? -1 : 1, h = pe(t, s);
  let {
    mainAxis: p,
    crossAxis: m,
    alignmentAxis: g
  } = typeof h == "number" ? {
    mainAxis: h,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: h.mainAxis || 0,
    crossAxis: h.crossAxis || 0,
    alignmentAxis: h.alignmentAxis
  };
  return a && typeof g == "number" && (m = a === "end" ? g * -1 : g), l ? {
    x: m * u,
    y: p * c
  } : {
    x: p * c,
    y: m * u
  };
}
var $i = function(s) {
  return {
    name: "offset",
    options: s,
    async fn(t) {
      var e, i;
      const {
        x: n,
        y: r,
        placement: o,
        middlewareData: a
      } = t, l = await fr(t, s);
      return o === ((e = a.offset) == null ? void 0 : e.placement) && (i = a.arrow) != null && i.alignmentOffset ? {} : {
        x: n + l.x,
        y: r + l.y,
        data: {
          ...l,
          placement: o
        }
      };
    }
  };
};
var mr = function(s) {
  return s === void 0 && (s = {}), {
    name: "shift",
    options: s,
    async fn(t) {
      const {
        x: e,
        y: i,
        placement: n
      } = t, {
        mainAxis: r = true,
        crossAxis: o = false,
        limiter: a = {
          fn: (b) => {
            let {
              x: w,
              y
            } = b;
            return {
              x: w,
              y
            };
          }
        },
        ...l
      } = pe(s, t), c = {
        x: e,
        y: i
      }, u = await ns(t, l), h = nt(rt(n)), p = Jn(h);
      let m = c[p], g = c[h];
      if (r) {
        const b = p === "y" ? "top" : "left", w = p === "y" ? "bottom" : "right", y = m + u[b], x = m - u[w];
        m = pn(y, m, x);
      }
      if (o) {
        const b = h === "y" ? "top" : "left", w = h === "y" ? "bottom" : "right", y = g + u[b], x = g - u[w];
        g = pn(y, g, x);
      }
      const v = a.fn({
        ...t,
        [p]: m,
        [h]: g
      });
      return {
        ...v,
        data: {
          x: v.x - e,
          y: v.y - i,
          enabled: {
            [p]: r,
            [h]: o
          }
        }
      };
    }
  };
};
function Ne() {
  return typeof window < "u";
}
function ft(s) {
  return rs(s) ? (s.nodeName || "").toLowerCase() : "#document";
}
function D(s) {
  var t;
  return (s == null || (t = s.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function wt(s) {
  var t;
  return (t = (rs(s) ? s.ownerDocument : s.document) || window.document) == null ? void 0 : t.documentElement;
}
function rs(s) {
  return Ne() ? s instanceof Node || s instanceof D(s).Node : false;
}
function X(s) {
  return Ne() ? s instanceof Element || s instanceof D(s).Element : false;
}
function Z(s) {
  return Ne() ? s instanceof HTMLElement || s instanceof D(s).HTMLElement : false;
}
function gn(s) {
  return !Ne() || typeof ShadowRoot > "u" ? false : s instanceof ShadowRoot || s instanceof D(s).ShadowRoot;
}
var br = /* @__PURE__ */ new Set(["inline", "contents"]);
function fe(s) {
  const {
    overflow: t,
    overflowX: e,
    overflowY: i,
    display: n
  } = F(s);
  return /auto|scroll|overlay|hidden|clip/.test(t + i + e) && !br.has(n);
}
var gr = /* @__PURE__ */ new Set(["table", "td", "th"]);
function vr(s) {
  return gr.has(ft(s));
}
var yr = [":popover-open", ":modal"];
function _r(s) {
  return yr.some((t) => {
    try {
      return s.matches(t);
    } catch {
      return false;
    }
  });
}
var wr = ["transform", "translate", "scale", "rotate", "perspective"];
var xr = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var $r = ["paint", "layout", "strict", "content"];
function Ci(s) {
  const t = Ai(), e = X(s) ? F(s) : s;
  return wr.some((i) => e[i] ? e[i] !== "none" : false) || (e.containerType ? e.containerType !== "normal" : false) || !t && (e.backdropFilter ? e.backdropFilter !== "none" : false) || !t && (e.filter ? e.filter !== "none" : false) || xr.some((i) => (e.willChange || "").includes(i)) || $r.some((i) => (e.contain || "").includes(i));
}
function Cr(s) {
  let t = Nt(s);
  for (; Z(t) && !qe(t); ) {
    if (Ci(t))
      return t;
    if (_r(t))
      return null;
    t = Nt(t);
  }
  return null;
}
function Ai() {
  return typeof CSS > "u" || !CSS.supports ? false : CSS.supports("-webkit-backdrop-filter", "none");
}
var Ar = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function qe(s) {
  return Ar.has(ft(s));
}
function F(s) {
  return D(s).getComputedStyle(s);
}
function Ve(s) {
  return X(s) ? {
    scrollLeft: s.scrollLeft,
    scrollTop: s.scrollTop
  } : {
    scrollLeft: s.scrollX,
    scrollTop: s.scrollY
  };
}
function Nt(s) {
  if (ft(s) === "html")
    return s;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    s.assignedSlot || // DOM Element detected.
    s.parentNode || // ShadowRoot detected.
    gn(s) && s.host || // Fallback.
    wt(s)
  );
  return gn(t) ? t.host : t;
}
function os(s) {
  const t = Nt(s);
  return qe(t) ? s.ownerDocument ? s.ownerDocument.body : s.body : Z(t) && fe(t) ? t : os(t);
}
function as(s, t, e) {
  var i;
  t === void 0 && (t = []);
  const n = os(s), r = n === ((i = s.ownerDocument) == null ? void 0 : i.body), o = D(n);
  return r ? (Sr(o), t.concat(o, o.visualViewport || [], fe(n) ? n : [], [])) : t.concat(n, as(n, []));
}
function Sr(s) {
  return s.parent && Object.getPrototypeOf(s.parent) ? s.frameElement : null;
}
function ls(s) {
  const t = F(s);
  let e = parseFloat(t.width) || 0, i = parseFloat(t.height) || 0;
  const n = Z(s), r = n ? s.offsetWidth : e, o = n ? s.offsetHeight : i, a = ke(e) !== r || ke(i) !== o;
  return a && (e = r, i = o), {
    width: e,
    height: i,
    $: a
  };
}
function cs(s) {
  return X(s) ? s : s.contextElement;
}
function jt(s) {
  const t = cs(s);
  if (!Z(t))
    return pt(1);
  const e = t.getBoundingClientRect(), {
    width: i,
    height: n,
    $: r
  } = ls(t);
  let o = (r ? ke(e.width) : e.width) / i, a = (r ? ke(e.height) : e.height) / n;
  return (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: o,
    y: a
  };
}
var Er = pt(0);
function us(s) {
  const t = D(s);
  return !Ai() || !t.visualViewport ? Er : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function kr(s, t, e) {
  return t === void 0 && (t = false), !e || t && e !== D(s) ? false : t;
}
function se(s, t, e, i) {
  t === void 0 && (t = false), e === void 0 && (e = false);
  const n = s.getBoundingClientRect(), r = cs(s);
  let o = pt(1);
  t && (i ? X(i) && (o = jt(i)) : o = jt(s));
  const a = kr(r, e, i) ? us(r) : pt(0);
  let l = (n.left + a.x) / o.x, c = (n.top + a.y) / o.y, u = n.width / o.x, h = n.height / o.y;
  if (r) {
    const p = D(r), m = i && X(i) ? D(i) : i;
    let g = p, v = g.frameElement;
    for (; v && i && m !== g; ) {
      const b = jt(v), w = v.getBoundingClientRect(), y = F(v), x = w.left + (v.clientLeft + parseFloat(y.paddingLeft)) * b.x, A = w.top + (v.clientTop + parseFloat(y.paddingTop)) * b.y;
      l *= b.x, c *= b.y, u *= b.x, h *= b.y, l += x, c += A, g = D(v), v = g.frameElement;
    }
  }
  return Ft({
    width: u,
    height: h,
    x: l,
    y: c
  });
}
var Pr = [":popover-open", ":modal"];
function hs(s) {
  return Pr.some((t) => {
    try {
      return s.matches(t);
    } catch {
      return false;
    }
  });
}
function Tr(s) {
  let {
    elements: t,
    rect: e,
    offsetParent: i,
    strategy: n
  } = s;
  const r = n === "fixed", o = wt(i), a = t ? hs(t.floating) : false;
  if (i === o || a && r)
    return e;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = pt(1);
  const u = pt(0), h = Z(i);
  if ((h || !h && !r) && ((ft(i) !== "body" || fe(o)) && (l = Ve(i)), Z(i))) {
    const p = se(i);
    c = jt(i), u.x = p.x + i.clientLeft, u.y = p.y + i.clientTop;
  }
  return {
    width: e.width * c.x,
    height: e.height * c.y,
    x: e.x * c.x - l.scrollLeft * c.x + u.x,
    y: e.y * c.y - l.scrollTop * c.y + u.y
  };
}
function Or(s) {
  return Array.from(s.getClientRects());
}
function ds(s) {
  return se(wt(s)).left + Ve(s).scrollLeft;
}
function Ir(s) {
  const t = wt(s), e = Ve(s), i = s.ownerDocument.body, n = st(t.scrollWidth, t.clientWidth, i.scrollWidth, i.clientWidth), r = st(t.scrollHeight, t.clientHeight, i.scrollHeight, i.clientHeight);
  let o = -e.scrollLeft + ds(s);
  const a = -e.scrollTop;
  return F(i).direction === "rtl" && (o += st(t.clientWidth, i.clientWidth) - n), {
    width: n,
    height: r,
    x: o,
    y: a
  };
}
function Lr(s, t) {
  const e = D(s), i = wt(s), n = e.visualViewport;
  let r = i.clientWidth, o = i.clientHeight, a = 0, l = 0;
  if (n) {
    r = n.width, o = n.height;
    const c = Ai();
    (!c || c && t === "fixed") && (a = n.offsetLeft, l = n.offsetTop);
  }
  return {
    width: r,
    height: o,
    x: a,
    y: l
  };
}
function Rr(s, t) {
  const e = se(s, true, t === "fixed"), i = e.top + s.clientTop, n = e.left + s.clientLeft, r = Z(s) ? jt(s) : pt(1), o = s.clientWidth * r.x, a = s.clientHeight * r.y, l = n * r.x, c = i * r.y;
  return {
    width: o,
    height: a,
    x: l,
    y: c
  };
}
function vn(s, t, e) {
  let i;
  if (t === "viewport")
    i = Lr(s, e);
  else if (t === "document")
    i = Ir(wt(s));
  else if (X(t))
    i = Rr(t, e);
  else {
    const n = us(s);
    i = {
      ...t,
      x: t.x - n.x,
      y: t.y - n.y
    };
  }
  return Ft(i);
}
function ps(s, t) {
  const e = Nt(s);
  return e === t || !X(e) || qe(e) ? false : F(e).position === "fixed" || ps(e, t);
}
function zr(s, t) {
  const e = t.get(s);
  if (e)
    return e;
  let i = as(s, []).filter((a) => X(a) && ft(a) !== "body"), n = null;
  const r = F(s).position === "fixed";
  let o = r ? Nt(s) : s;
  for (; X(o) && !qe(o); ) {
    const a = F(o), l = Ci(o);
    !l && a.position === "fixed" && (n = null), (r ? !l && !n : !l && a.position === "static" && !!n && ["absolute", "fixed"].includes(n.position) || fe(o) && !l && ps(s, o)) ? i = i.filter((u) => u !== o) : n = a, o = Nt(o);
  }
  return t.set(s, i), i;
}
function Br(s) {
  let {
    element: t,
    boundary: e,
    rootBoundary: i,
    strategy: n
  } = s;
  const o = [...e === "clippingAncestors" ? zr(t, this._c) : [].concat(e), i], a = o[0], l = o.reduce((c, u) => {
    const h = vn(t, u, n);
    return c.top = st(h.top, c.top), c.right = Ht(h.right, c.right), c.bottom = Ht(h.bottom, c.bottom), c.left = st(h.left, c.left), c;
  }, vn(t, a, n));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function Mr(s) {
  const {
    width: t,
    height: e
  } = ls(s);
  return {
    width: t,
    height: e
  };
}
function jr(s, t, e) {
  const i = Z(t), n = wt(t), r = e === "fixed", o = se(s, true, r, t);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = pt(0);
  if (i || !i && !r)
    if ((ft(t) !== "body" || fe(n)) && (a = Ve(t)), i) {
      const h = se(t, true, r, t);
      l.x = h.x + t.clientLeft, l.y = h.y + t.clientTop;
    } else
      n && (l.x = ds(n));
  const c = o.left + a.scrollLeft - l.x, u = o.top + a.scrollTop - l.y;
  return {
    x: c,
    y: u,
    width: o.width,
    height: o.height
  };
}
function yn(s, t) {
  return !Z(s) || F(s).position === "fixed" ? null : t ? t(s) : s.offsetParent;
}
function fs(s, t) {
  const e = D(s);
  if (!Z(s) || hs(s))
    return e;
  let i = yn(s, t);
  for (; i && vr(i) && F(i).position === "static"; )
    i = yn(i, t);
  return i && (ft(i) === "html" || ft(i) === "body" && F(i).position === "static" && !Ci(i)) ? e : i || Cr(s) || e;
}
var Dr = async function(s) {
  const t = this.getOffsetParent || fs, e = this.getDimensions;
  return {
    reference: jr(s.reference, await t(s.floating), s.strategy),
    floating: {
      x: 0,
      y: 0,
      ...await e(s.floating)
    }
  };
};
function Hr(s) {
  return F(s).direction === "rtl";
}
var Fr = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Tr,
  getDocumentElement: wt,
  getClippingRect: Br,
  getOffsetParent: fs,
  getElementRects: Dr,
  getClientRects: Or,
  getDimensions: Mr,
  getScale: jt,
  isElement: X,
  isRTL: Hr
};
var Si = mr;
var Ei = ur;
var ki = dr;
var Pi = (s, t, e) => {
  const i = /* @__PURE__ */ new Map(), n = {
    platform: Fr,
    ...e
  }, r = {
    ...n.platform,
    _c: i
  };
  return cr(s, t, {
    ...n,
    platform: r
  });
};
var Ce = globalThis;
var Ti = Ce.ShadowRoot && (Ce.ShadyCSS === void 0 || Ce.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var Oi = /* @__PURE__ */ Symbol();
var _n = /* @__PURE__ */ new WeakMap();
var ms = class {
  constructor(t, e, i) {
    if (this._$cssResult$ = true, i !== Oi)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if (Ti && t === void 0) {
      const i = e !== void 0 && e.length === 1;
      i && (t = _n.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), i && _n.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
var Nr = (s) => new ms(typeof s == "string" ? s : s + "", void 0, Oi);
var S = (s, ...t) => {
  const e = s.length === 1 ? s[0] : t.reduce((i, n, r) => i + ((o) => {
    if (o._$cssResult$ === true)
      return o.cssText;
    if (typeof o == "number")
      return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(n) + s[r + 1], s[0]);
  return new ms(e, s, Oi);
};
var qr = (s, t) => {
  if (Ti)
    s.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet);
  else
    for (const e of t) {
      const i = document.createElement("style"), n = Ce.litNonce;
      n !== void 0 && i.setAttribute("nonce", n), i.textContent = e.cssText, s.appendChild(i);
    }
};
var wn = Ti ? (s) => s : (s) => s instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const i of t.cssRules)
    e += i.cssText;
  return Nr(e);
})(s) : s;
var { is: Vr, defineProperty: Ur, getOwnPropertyDescriptor: Wr, getOwnPropertyNames: Yr, getOwnPropertySymbols: Gr, getPrototypeOf: Qr } = Object;
var dt = globalThis;
var xn = dt.trustedTypes;
var Kr = xn ? xn.emptyScript : "";
var Je = dt.reactiveElementPolyfillSupport;
var Jt = (s, t) => s;
var Te = { toAttribute(s, t) {
  switch (t) {
    case Boolean:
      s = s ? Kr : null;
      break;
    case Object:
    case Array:
      s = s == null ? s : JSON.stringify(s);
  }
  return s;
}, fromAttribute(s, t) {
  let e = s;
  switch (t) {
    case Boolean:
      e = s !== null;
      break;
    case Number:
      e = s === null ? null : Number(s);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(s);
      } catch {
        e = null;
      }
  }
  return e;
} };
var Ii = (s, t) => !Vr(s, t);
var $n = { attribute: true, type: String, converter: Te, reflect: false, useDefault: false, hasChanged: Ii };
Symbol.metadata ?? (Symbol.metadata = /* @__PURE__ */ Symbol("metadata")), dt.litPropertyMetadata ?? (dt.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
var Mt = class extends HTMLElement {
  static addInitializer(t) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t, e = $n) {
    if (e.state && (e.attribute = false), this._$Ei(), this.prototype.hasOwnProperty(t) && ((e = Object.create(e)).wrapped = true), this.elementProperties.set(t, e), !e.noAccessor) {
      const i = /* @__PURE__ */ Symbol(), n = this.getPropertyDescriptor(t, i, e);
      n !== void 0 && Ur(this.prototype, t, n);
    }
  }
  static getPropertyDescriptor(t, e, i) {
    const { get: n, set: r } = Wr(this.prototype, t) ?? { get() {
      return this[e];
    }, set(o) {
      this[e] = o;
    } };
    return { get: n, set(o) {
      const a = n == null ? void 0 : n.call(this);
      r == null || r.call(this, o), this.requestUpdate(t, a, i);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) ?? $n;
  }
  static _$Ei() {
    if (this.hasOwnProperty(Jt("elementProperties")))
      return;
    const t = Qr(this);
    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(Jt("finalized")))
      return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(Jt("properties"))) {
      const e = this.properties, i = [...Yr(e), ...Gr(e)];
      for (const n of i)
        this.createProperty(n, e[n]);
    }
    const t = this[Symbol.metadata];
    if (t !== null) {
      const e = litPropertyMetadata.get(t);
      if (e !== void 0)
        for (const [i, n] of e)
          this.elementProperties.set(i, n);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [e, i] of this.elementProperties) {
      const n = this._$Eu(e, i);
      n !== void 0 && this._$Eh.set(n, e);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const i = new Set(t.flat(1 / 0).reverse());
      for (const n of i)
        e.unshift(wn(n));
    } else
      t !== void 0 && e.push(wn(t));
    return e;
  }
  static _$Eu(t, e) {
    const i = e.attribute;
    return i === false ? void 0 : typeof i == "string" ? i : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var t;
    this._$ES = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (t = this.constructor.l) == null || t.forEach((e) => e(this));
  }
  addController(t) {
    var e;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t), this.renderRoot !== void 0 && this.isConnected && ((e = t.hostConnected) == null || e.call(t));
  }
  removeController(t) {
    var e;
    (e = this._$EO) == null || e.delete(t);
  }
  _$E_() {
    const t = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;
    for (const i of e.keys())
      this.hasOwnProperty(i) && (t.set(i, this[i]), delete this[i]);
    t.size > 0 && (this._$Ep = t);
  }
  createRenderRoot() {
    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return qr(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    var t;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), (t = this._$EO) == null || t.forEach((e) => {
      var i;
      return (i = e.hostConnected) == null ? void 0 : i.call(e);
    });
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    var t;
    (t = this._$EO) == null || t.forEach((e) => {
      var i;
      return (i = e.hostDisconnected) == null ? void 0 : i.call(e);
    });
  }
  attributeChangedCallback(t, e, i) {
    this._$AK(t, i);
  }
  _$ET(t, e) {
    var r;
    const i = this.constructor.elementProperties.get(t), n = this.constructor._$Eu(t, i);
    if (n !== void 0 && i.reflect === true) {
      const o = (((r = i.converter) == null ? void 0 : r.toAttribute) !== void 0 ? i.converter : Te).toAttribute(e, i.type);
      this._$Em = t, o == null ? this.removeAttribute(n) : this.setAttribute(n, o), this._$Em = null;
    }
  }
  _$AK(t, e) {
    var r, o;
    const i = this.constructor, n = i._$Eh.get(t);
    if (n !== void 0 && this._$Em !== n) {
      const a = i.getPropertyOptions(n), l = typeof a.converter == "function" ? { fromAttribute: a.converter } : ((r = a.converter) == null ? void 0 : r.fromAttribute) !== void 0 ? a.converter : Te;
      this._$Em = n;
      const c = l.fromAttribute(e, a.type);
      this[n] = c ?? ((o = this._$Ej) == null ? void 0 : o.get(n)) ?? c, this._$Em = null;
    }
  }
  requestUpdate(t, e, i, n = false, r) {
    var o;
    if (t !== void 0) {
      const a = this.constructor;
      if (n === false && (r = this[t]), i ?? (i = a.getPropertyOptions(t)), !((i.hasChanged ?? Ii)(r, e) || i.useDefault && i.reflect && r === ((o = this._$Ej) == null ? void 0 : o.get(t)) && !this.hasAttribute(a._$Eu(t, i))))
        return;
      this.C(t, e, i);
    }
    this.isUpdatePending === false && (this._$ES = this._$EP());
  }
  C(t, e, { useDefault: i, reflect: n, wrapped: r }, o) {
    i && !(this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Map())).has(t) && (this._$Ej.set(t, o ?? e ?? this[t]), r !== true || o !== void 0) || (this._$AL.has(t) || (this.hasUpdated || i || (e = void 0), this._$AL.set(t, e)), n === true && this._$Em !== t && (this._$Eq ?? (this._$Eq = /* @__PURE__ */ new Set())).add(t));
  }
  async _$EP() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var i;
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [r, o] of this._$Ep)
          this[r] = o;
        this._$Ep = void 0;
      }
      const n = this.constructor.elementProperties;
      if (n.size > 0)
        for (const [r, o] of n) {
          const { wrapped: a } = o, l = this[r];
          a !== true || this._$AL.has(r) || l === void 0 || this.C(r, void 0, o, l);
        }
    }
    let t = false;
    const e = this._$AL;
    try {
      t = this.shouldUpdate(e), t ? (this.willUpdate(e), (i = this._$EO) == null || i.forEach((n) => {
        var r;
        return (r = n.hostUpdate) == null ? void 0 : r.call(n);
      }), this.update(e)) : this._$EM();
    } catch (n) {
      throw t = false, this._$EM(), n;
    }
    t && this._$AE(e);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    var e;
    (e = this._$EO) == null || e.forEach((i) => {
      var n;
      return (n = i.hostUpdated) == null ? void 0 : n.call(i);
    }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t)), this.updated(t);
  }
  _$EM() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t) {
    return true;
  }
  update(t) {
    this._$Eq && (this._$Eq = this._$Eq.forEach((e) => this._$ET(e, this[e]))), this._$EM();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
};
Mt.elementStyles = [], Mt.shadowRootOptions = { mode: "open" }, Mt[Jt("elementProperties")] = /* @__PURE__ */ new Map(), Mt[Jt("finalized")] = /* @__PURE__ */ new Map(), Je == null || Je({ ReactiveElement: Mt }), (dt.reactiveElementVersions ?? (dt.reactiveElementVersions = [])).push("2.1.2");
var te = globalThis;
var Cn = (s) => s;
var Oe = te.trustedTypes;
var An = Oe ? Oe.createPolicy("lit-html", { createHTML: (s) => s }) : void 0;
var bs = "$lit$";
var ht = `lit$${Math.random().toFixed(9).slice(2)}$`;
var gs = "?" + ht;
var Xr = `<${gs}>`;
var Tt = document;
var re = () => Tt.createComment("");
var oe = (s) => s === null || typeof s != "object" && typeof s != "function";
var Li = Array.isArray;
var Zr = (s) => Li(s) || typeof (s == null ? void 0 : s[Symbol.iterator]) == "function";
var ti = `[ 	
\f\r]`;
var Xt = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var Sn = /-->/g;
var En = />/g;
var At = RegExp(`>|${ti}(?:([^\\s"'>=/]+)(${ti}*=${ti}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var kn = /'/g;
var Pn = /"/g;
var vs = /^(?:script|style|textarea|title)$/i;
var Jr = (s) => (t, ...e) => ({ _$litType$: s, strings: t, values: e });
var f = Jr(1);
var Ot = /* @__PURE__ */ Symbol.for("lit-noChange");
var E = /* @__PURE__ */ Symbol.for("lit-nothing");
var Tn = /* @__PURE__ */ new WeakMap();
var St = Tt.createTreeWalker(Tt, 129);
function ys(s, t) {
  if (!Li(s) || !s.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return An !== void 0 ? An.createHTML(t) : t;
}
var to = (s, t) => {
  const e = s.length - 1, i = [];
  let n, r = t === 2 ? "<svg>" : t === 3 ? "<math>" : "", o = Xt;
  for (let a = 0; a < e; a++) {
    const l = s[a];
    let c, u, h = -1, p = 0;
    for (; p < l.length && (o.lastIndex = p, u = o.exec(l), u !== null); )
      p = o.lastIndex, o === Xt ? u[1] === "!--" ? o = Sn : u[1] !== void 0 ? o = En : u[2] !== void 0 ? (vs.test(u[2]) && (n = RegExp("</" + u[2], "g")), o = At) : u[3] !== void 0 && (o = At) : o === At ? u[0] === ">" ? (o = n ?? Xt, h = -1) : u[1] === void 0 ? h = -2 : (h = o.lastIndex - u[2].length, c = u[1], o = u[3] === void 0 ? At : u[3] === '"' ? Pn : kn) : o === Pn || o === kn ? o = At : o === Sn || o === En ? o = Xt : (o = At, n = void 0);
    const m = o === At && s[a + 1].startsWith("/>") ? " " : "";
    r += o === Xt ? l + Xr : h >= 0 ? (i.push(c), l.slice(0, h) + bs + l.slice(h) + ht + m) : l + ht + (h === -2 ? a : m);
  }
  return [ys(s, r + (s[e] || "<?>") + (t === 2 ? "</svg>" : t === 3 ? "</math>" : "")), i];
};
var ae = class _ae {
  constructor({ strings: t, _$litType$: e }, i) {
    let n;
    this.parts = [];
    let r = 0, o = 0;
    const a = t.length - 1, l = this.parts, [c, u] = to(t, e);
    if (this.el = _ae.createElement(c, i), St.currentNode = this.el.content, e === 2 || e === 3) {
      const h = this.el.content.firstChild;
      h.replaceWith(...h.childNodes);
    }
    for (; (n = St.nextNode()) !== null && l.length < a; ) {
      if (n.nodeType === 1) {
        if (n.hasAttributes())
          for (const h of n.getAttributeNames())
            if (h.endsWith(bs)) {
              const p = u[o++], m = n.getAttribute(h).split(ht), g = /([.?@])?(.*)/.exec(p);
              l.push({ type: 1, index: r, name: g[2], strings: m, ctor: g[1] === "." ? io : g[1] === "?" ? no : g[1] === "@" ? so : Ue }), n.removeAttribute(h);
            } else
              h.startsWith(ht) && (l.push({ type: 6, index: r }), n.removeAttribute(h));
        if (vs.test(n.tagName)) {
          const h = n.textContent.split(ht), p = h.length - 1;
          if (p > 0) {
            n.textContent = Oe ? Oe.emptyScript : "";
            for (let m = 0; m < p; m++)
              n.append(h[m], re()), St.nextNode(), l.push({ type: 2, index: ++r });
            n.append(h[p], re());
          }
        }
      } else if (n.nodeType === 8)
        if (n.data === gs)
          l.push({ type: 2, index: r });
        else {
          let h = -1;
          for (; (h = n.data.indexOf(ht, h + 1)) !== -1; )
            l.push({ type: 7, index: r }), h += ht.length - 1;
        }
      r++;
    }
  }
  static createElement(t, e) {
    const i = Tt.createElement("template");
    return i.innerHTML = t, i;
  }
};
function qt(s, t, e = s, i) {
  var o, a;
  if (t === Ot)
    return t;
  let n = i !== void 0 ? (o = e._$Co) == null ? void 0 : o[i] : e._$Cl;
  const r = oe(t) ? void 0 : t._$litDirective$;
  return (n == null ? void 0 : n.constructor) !== r && ((a = n == null ? void 0 : n._$AO) == null || a.call(n, false), r === void 0 ? n = void 0 : (n = new r(s), n._$AT(s, e, i)), i !== void 0 ? (e._$Co ?? (e._$Co = []))[i] = n : e._$Cl = n), n !== void 0 && (t = qt(s, n._$AS(s, t.values), n, i)), t;
}
var eo = class {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const { el: { content: e }, parts: i } = this._$AD, n = ((t == null ? void 0 : t.creationScope) ?? Tt).importNode(e, true);
    St.currentNode = n;
    let r = St.nextNode(), o = 0, a = 0, l = i[0];
    for (; l !== void 0; ) {
      if (o === l.index) {
        let c;
        l.type === 2 ? c = new me(r, r.nextSibling, this, t) : l.type === 1 ? c = new l.ctor(r, l.name, l.strings, this, t) : l.type === 6 && (c = new ro(r, this, t)), this._$AV.push(c), l = i[++a];
      }
      o !== (l == null ? void 0 : l.index) && (r = St.nextNode(), o++);
    }
    return St.currentNode = Tt, n;
  }
  p(t) {
    let e = 0;
    for (const i of this._$AV)
      i !== void 0 && (i.strings !== void 0 ? (i._$AI(t, i, e), e += i.strings.length - 2) : i._$AI(t[e])), e++;
  }
};
var me = class _me {
  get _$AU() {
    var t;
    return ((t = this._$AM) == null ? void 0 : t._$AU) ?? this._$Cv;
  }
  constructor(t, e, i, n) {
    this.type = 2, this._$AH = E, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = i, this.options = n, this._$Cv = (n == null ? void 0 : n.isConnected) ?? true;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = qt(this, t, e), oe(t) ? t === E || t == null || t === "" ? (this._$AH !== E && this._$AR(), this._$AH = E) : t !== this._$AH && t !== Ot && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : Zr(t) ? this.k(t) : this._(t);
  }
  O(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.O(t));
  }
  _(t) {
    this._$AH !== E && oe(this._$AH) ? this._$AA.nextSibling.data = t : this.T(Tt.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    var r;
    const { values: e, _$litType$: i } = t, n = typeof i == "number" ? this._$AC(t) : (i.el === void 0 && (i.el = ae.createElement(ys(i.h, i.h[0]), this.options)), i);
    if (((r = this._$AH) == null ? void 0 : r._$AD) === n)
      this._$AH.p(e);
    else {
      const o = new eo(n, this), a = o.u(this.options);
      o.p(e), this.T(a), this._$AH = o;
    }
  }
  _$AC(t) {
    let e = Tn.get(t.strings);
    return e === void 0 && Tn.set(t.strings, e = new ae(t)), e;
  }
  k(t) {
    Li(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let i, n = 0;
    for (const r of t)
      n === e.length ? e.push(i = new _me(this.O(re()), this.O(re()), this, this.options)) : i = e[n], i._$AI(r), n++;
    n < e.length && (this._$AR(i && i._$AB.nextSibling, n), e.length = n);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    var i;
    for ((i = this._$AP) == null ? void 0 : i.call(this, false, true, e); t !== this._$AB; ) {
      const n = Cn(t).nextSibling;
      Cn(t).remove(), t = n;
    }
  }
  setConnected(t) {
    var e;
    this._$AM === void 0 && (this._$Cv = t, (e = this._$AP) == null || e.call(this, t));
  }
};
var Ue = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, e, i, n, r) {
    this.type = 1, this._$AH = E, this._$AN = void 0, this.element = t, this.name = e, this._$AM = n, this.options = r, i.length > 2 || i[0] !== "" || i[1] !== "" ? (this._$AH = Array(i.length - 1).fill(new String()), this.strings = i) : this._$AH = E;
  }
  _$AI(t, e = this, i, n) {
    const r = this.strings;
    let o = false;
    if (r === void 0)
      t = qt(this, t, e, 0), o = !oe(t) || t !== this._$AH && t !== Ot, o && (this._$AH = t);
    else {
      const a = t;
      let l, c;
      for (t = r[0], l = 0; l < r.length - 1; l++)
        c = qt(this, a[i + l], e, l), c === Ot && (c = this._$AH[l]), o || (o = !oe(c) || c !== this._$AH[l]), c === E ? t = E : t !== E && (t += (c ?? "") + r[l + 1]), this._$AH[l] = c;
    }
    o && !n && this.j(t);
  }
  j(t) {
    t === E ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
};
var io = class extends Ue {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === E ? void 0 : t;
  }
};
var no = class extends Ue {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== E);
  }
};
var so = class extends Ue {
  constructor(t, e, i, n, r) {
    super(t, e, i, n, r), this.type = 5;
  }
  _$AI(t, e = this) {
    if ((t = qt(this, t, e, 0) ?? E) === Ot)
      return;
    const i = this._$AH, n = t === E && i !== E || t.capture !== i.capture || t.once !== i.once || t.passive !== i.passive, r = t !== E && (i === E || n);
    n && this.element.removeEventListener(this.name, this, i), r && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var e;
    typeof this._$AH == "function" ? this._$AH.call(((e = this.options) == null ? void 0 : e.host) ?? this.element, t) : this._$AH.handleEvent(t);
  }
};
var ro = class {
  constructor(t, e, i) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = i;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    qt(this, t);
  }
};
var ei = te.litHtmlPolyfillSupport;
ei == null || ei(ae, me), (te.litHtmlVersions ?? (te.litHtmlVersions = [])).push("3.3.2");
var ci = (s, t, e) => {
  const i = (e == null ? void 0 : e.renderBefore) ?? t;
  let n = i._$litPart$;
  if (n === void 0) {
    const r = (e == null ? void 0 : e.renderBefore) ?? null;
    i._$litPart$ = n = new me(t.insertBefore(re(), r), r, void 0, e ?? {});
  }
  return n._$AI(s), n;
};
var Et = globalThis;
var C = class extends Mt {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var e;
    const t = super.createRenderRoot();
    return (e = this.renderOptions).renderBefore ?? (e.renderBefore = t.firstChild), t;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = ci(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this._$Do) == null || t.setConnected(true);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this._$Do) == null || t.setConnected(false);
  }
  render() {
    return Ot;
  }
};
var Zn;
C._$litElement$ = true, C.finalized = true, (Zn = Et.litElementHydrateSupport) == null || Zn.call(Et, { LitElement: C });
var ii = Et.litElementPolyfillSupport;
ii == null || ii({ LitElement: C });
(Et.litElementVersions ?? (Et.litElementVersions = [])).push("4.2.2");
var oo = { attribute: true, type: String, converter: Te, reflect: false, hasChanged: Ii };
var ao = (s = oo, t, e) => {
  const { kind: i, metadata: n } = e;
  let r = globalThis.litPropertyMetadata.get(n);
  if (r === void 0 && globalThis.litPropertyMetadata.set(n, r = /* @__PURE__ */ new Map()), i === "setter" && ((s = Object.create(s)).wrapped = true), r.set(e.name, s), i === "accessor") {
    const { name: o } = e;
    return { set(a) {
      const l = t.get.call(this);
      t.set.call(this, a), this.requestUpdate(o, l, s, true, a);
    }, init(a) {
      return a !== void 0 && this.C(o, void 0, s, a), a;
    } };
  }
  if (i === "setter") {
    const { name: o } = e;
    return function(a) {
      const l = this[o];
      t.call(this, a), this.requestUpdate(o, l, s, true, a);
    };
  }
  throw Error("Unsupported decorator location: " + i);
};
function d(s) {
  return (t, e) => typeof e == "object" ? ao(s, t, e) : ((i, n, r) => {
    const o = n.hasOwnProperty(r);
    return n.constructor.createProperty(r, i), o ? Object.getOwnPropertyDescriptor(n, r) : void 0;
  })(s, t, e);
}
function Lt(s) {
  return d({ ...s, state: true, attribute: false });
}
var lo = (s) => s.strings === void 0;
var _s = { ATTRIBUTE: 1, CHILD: 2 };
var ws = (s) => (...t) => ({ _$litDirective$: s, values: t });
var xs = class {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, e, i) {
    this._$Ct = t, this._$AM = e, this._$Ci = i;
  }
  _$AS(t, e) {
    return this.update(t, e);
  }
  update(t, e) {
    return this.render(...e);
  }
};
var ee = (s, t) => {
  var i;
  const e = s._$AN;
  if (e === void 0)
    return false;
  for (const n of e)
    (i = n._$AO) == null || i.call(n, t, false), ee(n, t);
  return true;
};
var Ie = (s) => {
  let t, e;
  do {
    if ((t = s._$AM) === void 0)
      break;
    e = t._$AN, e.delete(s), s = t;
  } while ((e == null ? void 0 : e.size) === 0);
};
var $s = (s) => {
  for (let t; t = s._$AM; s = t) {
    let e = t._$AN;
    if (e === void 0)
      t._$AN = e = /* @__PURE__ */ new Set();
    else if (e.has(s))
      break;
    e.add(s), ho(t);
  }
};
function co(s) {
  this._$AN !== void 0 ? (Ie(this), this._$AM = s, $s(this)) : this._$AM = s;
}
function uo(s, t = false, e = 0) {
  const i = this._$AH, n = this._$AN;
  if (n !== void 0 && n.size !== 0)
    if (t)
      if (Array.isArray(i))
        for (let r = e; r < i.length; r++)
          ee(i[r], false), Ie(i[r]);
      else
        i != null && (ee(i, false), Ie(i));
    else
      ee(this, s);
}
var ho = (s) => {
  s.type == _s.CHILD && (s._$AP ?? (s._$AP = uo), s._$AQ ?? (s._$AQ = co));
};
var po = class extends xs {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(t, e, i) {
    super._$AT(t, e, i), $s(this), this.isConnected = t._$AU;
  }
  _$AO(t, e = true) {
    var i, n;
    t !== this.isConnected && (this.isConnected = t, t ? (i = this.reconnected) == null || i.call(this) : (n = this.disconnected) == null || n.call(this)), e && (ee(this, t), Ie(this));
  }
  setValue(t) {
    if (lo(this._$Ct))
      this._$Ct._$AI(t, this);
    else {
      const e = [...this._$Ct._$AH];
      e[this._$Ci] = t, this._$Ct._$AI(e, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
};
var Vt = () => new fo();
var fo = class {
};
var ni = /* @__PURE__ */ new WeakMap();
var J = ws(class extends po {
  render(s) {
    return E;
  }
  update(s, [t]) {
    var i;
    const e = t !== this.G;
    return e && this.G !== void 0 && this.rt(void 0), (e || this.lt !== this.ct) && (this.G = t, this.ht = (i = s.options) == null ? void 0 : i.host, this.rt(this.ct = s.element)), E;
  }
  rt(s) {
    if (this.isConnected || (s = void 0), typeof this.G == "function") {
      const t = this.ht ?? globalThis;
      let e = ni.get(t);
      e === void 0 && (e = /* @__PURE__ */ new WeakMap(), ni.set(t, e)), e.get(this.G) !== void 0 && this.G.call(this.ht, void 0), e.set(this.G, s), s !== void 0 && this.G.call(this.ht, s);
    } else
      this.G.value = s;
  }
  get lt() {
    var s, t;
    return typeof this.G == "function" ? (s = ni.get(this.ht ?? globalThis)) == null ? void 0 : s.get(this.G) : (t = this.G) == null ? void 0 : t.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
var Cs = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
);
var Le = Object.freeze({
  rotate: 0,
  vFlip: false,
  hFlip: false
});
var be = Object.freeze({
  ...Cs,
  ...Le
});
var ui = Object.freeze({
  ...be,
  body: "",
  hidden: false
});
var mo = Object.freeze({
  width: null,
  height: null
});
var As = Object.freeze({
  // Dimensions
  ...mo,
  // Transformations
  ...Le
});
function bo(s, t = 0) {
  const e = s.replace(/^-?[0-9.]*/, "");
  function i(n) {
    for (; n < 0; )
      n += 4;
    return n % 4;
  }
  if (e === "") {
    const n = parseInt(s);
    return isNaN(n) ? 0 : i(n);
  } else if (e !== s) {
    let n = 0;
    switch (e) {
      case "%":
        n = 25;
        break;
      case "deg":
        n = 90;
    }
    if (n) {
      let r = parseFloat(s.slice(0, s.length - e.length));
      return isNaN(r) ? 0 : (r = r / n, r % 1 === 0 ? i(r) : 0);
    }
  }
  return t;
}
var go = /[\s,]+/;
function vo(s, t) {
  t.split(go).forEach((e) => {
    switch (e.trim()) {
      case "horizontal":
        s.hFlip = true;
        break;
      case "vertical":
        s.vFlip = true;
        break;
    }
  });
}
var Ss = {
  ...As,
  preserveAspectRatio: ""
};
function On(s) {
  const t = {
    ...Ss
  }, e = (i, n) => s.getAttribute(i) || n;
  return t.width = e("width", null), t.height = e("height", null), t.rotate = bo(e("rotate", "")), vo(t, e("flip", "")), t.preserveAspectRatio = e("preserveAspectRatio", e("preserveaspectratio", "")), t;
}
function yo(s, t) {
  for (const e in Ss)
    if (s[e] !== t[e])
      return true;
  return false;
}
var ie = /^[a-z0-9]+(-[a-z0-9]+)*$/;
var ge = (s, t, e, i = "") => {
  const n = s.split(":");
  if (s.slice(0, 1) === "@") {
    if (n.length < 2 || n.length > 3)
      return null;
    i = n.shift().slice(1);
  }
  if (n.length > 3 || !n.length)
    return null;
  if (n.length > 1) {
    const a = n.pop(), l = n.pop(), c = {
      // Allow provider without '@': "provider:prefix:name"
      provider: n.length > 0 ? n[0] : i,
      prefix: l,
      name: a
    };
    return t && !Ae(c) ? null : c;
  }
  const r = n[0], o = r.split("-");
  if (o.length > 1) {
    const a = {
      provider: i,
      prefix: o.shift(),
      name: o.join("-")
    };
    return t && !Ae(a) ? null : a;
  }
  if (e && i === "") {
    const a = {
      provider: i,
      prefix: "",
      name: r
    };
    return t && !Ae(a, e) ? null : a;
  }
  return null;
};
var Ae = (s, t) => s ? !!((s.provider === "" || s.provider.match(ie)) && (t && s.prefix === "" || s.prefix.match(ie)) && s.name.match(ie)) : false;
function _o(s, t) {
  const e = {};
  !s.hFlip != !t.hFlip && (e.hFlip = true), !s.vFlip != !t.vFlip && (e.vFlip = true);
  const i = ((s.rotate || 0) + (t.rotate || 0)) % 4;
  return i && (e.rotate = i), e;
}
function In(s, t) {
  const e = _o(s, t);
  for (const i in ui)
    i in Le ? i in s && !(i in e) && (e[i] = Le[i]) : i in t ? e[i] = t[i] : i in s && (e[i] = s[i]);
  return e;
}
function wo(s, t) {
  const e = s.icons, i = s.aliases || /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
  function r(o) {
    if (e[o])
      return n[o] = [];
    if (!(o in n)) {
      n[o] = null;
      const a = i[o] && i[o].parent, l = a && r(a);
      l && (n[o] = [a].concat(l));
    }
    return n[o];
  }
  return Object.keys(e).concat(Object.keys(i)).forEach(r), n;
}
function xo(s, t, e) {
  const i = s.icons, n = s.aliases || /* @__PURE__ */ Object.create(null);
  let r = {};
  function o(a) {
    r = In(
      i[a] || n[a],
      r
    );
  }
  return o(t), e.forEach(o), In(s, r);
}
function Es(s, t) {
  const e = [];
  if (typeof s != "object" || typeof s.icons != "object")
    return e;
  s.not_found instanceof Array && s.not_found.forEach((n) => {
    t(n, null), e.push(n);
  });
  const i = wo(s);
  for (const n in i) {
    const r = i[n];
    r && (t(n, xo(s, n, r)), e.push(n));
  }
  return e;
}
var $o = {
  provider: "",
  aliases: {},
  not_found: {},
  ...Cs
};
function si(s, t) {
  for (const e in t)
    if (e in s && typeof s[e] != typeof t[e])
      return false;
  return true;
}
function ks(s) {
  if (typeof s != "object" || s === null)
    return null;
  const t = s;
  if (typeof t.prefix != "string" || !s.icons || typeof s.icons != "object" || !si(s, $o))
    return null;
  const e = t.icons;
  for (const n in e) {
    const r = e[n];
    if (!n.match(ie) || typeof r.body != "string" || !si(
      r,
      ui
    ))
      return null;
  }
  const i = t.aliases || /* @__PURE__ */ Object.create(null);
  for (const n in i) {
    const r = i[n], o = r.parent;
    if (!n.match(ie) || typeof o != "string" || !e[o] && !i[o] || !si(
      r,
      ui
    ))
      return null;
  }
  return t;
}
var Re = /* @__PURE__ */ Object.create(null);
function Co(s, t) {
  return {
    provider: s,
    prefix: t,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function mt(s, t) {
  const e = Re[s] || (Re[s] = /* @__PURE__ */ Object.create(null));
  return e[t] || (e[t] = Co(s, t));
}
function Ri(s, t) {
  return ks(t) ? Es(t, (e, i) => {
    i ? s.icons[e] = i : s.missing.add(e);
  }) : [];
}
function Ao(s, t, e) {
  try {
    if (typeof e.body == "string")
      return s.icons[t] = { ...e }, true;
  } catch {
  }
  return false;
}
function So(s, t) {
  let e = [];
  return (typeof s == "string" ? [s] : Object.keys(Re)).forEach((n) => {
    (typeof n == "string" && typeof t == "string" ? [t] : Object.keys(Re[n] || {})).forEach((o) => {
      const a = mt(n, o);
      e = e.concat(
        Object.keys(a.icons).map(
          (l) => (n !== "" ? "@" + n + ":" : "") + o + ":" + l
        )
      );
    });
  }), e;
}
var le = false;
function Ps(s) {
  return typeof s == "boolean" && (le = s), le;
}
function ce(s) {
  const t = typeof s == "string" ? ge(s, true, le) : s;
  if (t) {
    const e = mt(t.provider, t.prefix), i = t.name;
    return e.icons[i] || (e.missing.has(i) ? null : void 0);
  }
}
function Ts(s, t) {
  const e = ge(s, true, le);
  if (!e)
    return false;
  const i = mt(e.provider, e.prefix);
  return Ao(i, e.name, t);
}
function Ln(s, t) {
  if (typeof s != "object")
    return false;
  if (typeof t != "string" && (t = s.provider || ""), le && !t && !s.prefix) {
    let n = false;
    return ks(s) && (s.prefix = "", Es(s, (r, o) => {
      o && Ts(r, o) && (n = true);
    })), n;
  }
  const e = s.prefix;
  if (!Ae({
    provider: t,
    prefix: e,
    name: "a"
  }))
    return false;
  const i = mt(t, e);
  return !!Ri(i, s);
}
function Rn(s) {
  return !!ce(s);
}
function Eo(s) {
  const t = ce(s);
  return t ? {
    ...be,
    ...t
  } : null;
}
function ko(s) {
  const t = {
    loaded: [],
    missing: [],
    pending: []
  }, e = /* @__PURE__ */ Object.create(null);
  s.sort((n, r) => n.provider !== r.provider ? n.provider.localeCompare(r.provider) : n.prefix !== r.prefix ? n.prefix.localeCompare(r.prefix) : n.name.localeCompare(r.name));
  let i = {
    provider: "",
    prefix: "",
    name: ""
  };
  return s.forEach((n) => {
    if (i.name === n.name && i.prefix === n.prefix && i.provider === n.provider)
      return;
    i = n;
    const r = n.provider, o = n.prefix, a = n.name, l = e[r] || (e[r] = /* @__PURE__ */ Object.create(null)), c = l[o] || (l[o] = mt(r, o));
    let u;
    a in c.icons ? u = t.loaded : o === "" || c.missing.has(a) ? u = t.missing : u = t.pending;
    const h = {
      provider: r,
      prefix: o,
      name: a
    };
    u.push(h);
  }), t;
}
function Os(s, t) {
  s.forEach((e) => {
    const i = e.loaderCallbacks;
    i && (e.loaderCallbacks = i.filter((n) => n.id !== t));
  });
}
function Po(s) {
  s.pendingCallbacksFlag || (s.pendingCallbacksFlag = true, setTimeout(() => {
    s.pendingCallbacksFlag = false;
    const t = s.loaderCallbacks ? s.loaderCallbacks.slice(0) : [];
    if (!t.length)
      return;
    let e = false;
    const i = s.provider, n = s.prefix;
    t.forEach((r) => {
      const o = r.icons, a = o.pending.length;
      o.pending = o.pending.filter((l) => {
        if (l.prefix !== n)
          return true;
        const c = l.name;
        if (s.icons[c])
          o.loaded.push({
            provider: i,
            prefix: n,
            name: c
          });
        else if (s.missing.has(c))
          o.missing.push({
            provider: i,
            prefix: n,
            name: c
          });
        else
          return e = true, true;
        return false;
      }), o.pending.length !== a && (e || Os([s], r.id), r.callback(
        o.loaded.slice(0),
        o.missing.slice(0),
        o.pending.slice(0),
        r.abort
      ));
    });
  }));
}
var To = 0;
function Oo(s, t, e) {
  const i = To++, n = Os.bind(null, e, i);
  if (!t.pending.length)
    return n;
  const r = {
    id: i,
    icons: t,
    callback: s,
    abort: n
  };
  return e.forEach((o) => {
    (o.loaderCallbacks || (o.loaderCallbacks = [])).push(r);
  }), n;
}
var hi = /* @__PURE__ */ Object.create(null);
function zn(s, t) {
  hi[s] = t;
}
function di(s) {
  return hi[s] || hi[""];
}
function Io(s, t = true, e = false) {
  const i = [];
  return s.forEach((n) => {
    const r = typeof n == "string" ? ge(n, t, e) : n;
    r && i.push(r);
  }), i;
}
var Lo = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: false,
  dataAfterTimeout: false
};
function Ro(s, t, e, i) {
  const n = s.resources.length, r = s.random ? Math.floor(Math.random() * n) : s.index;
  let o;
  if (s.random) {
    let $ = s.resources.slice(0);
    for (o = []; $.length > 1; ) {
      const L = Math.floor(Math.random() * $.length);
      o.push($[L]), $ = $.slice(0, L).concat($.slice(L + 1));
    }
    o = o.concat($);
  } else
    o = s.resources.slice(r).concat(s.resources.slice(0, r));
  const a = Date.now();
  let l = "pending", c = 0, u, h = null, p = [], m = [];
  typeof i == "function" && m.push(i);
  function g() {
    h && (clearTimeout(h), h = null);
  }
  function v() {
    l === "pending" && (l = "aborted"), g(), p.forEach(($) => {
      $.status === "pending" && ($.status = "aborted");
    }), p = [];
  }
  function b($, L) {
    L && (m = []), typeof $ == "function" && m.push($);
  }
  function w() {
    return {
      startTime: a,
      payload: t,
      status: l,
      queriesSent: c,
      queriesPending: p.length,
      subscribe: b,
      abort: v
    };
  }
  function y() {
    l = "failed", m.forEach(($) => {
      $(void 0, u);
    });
  }
  function x() {
    p.forEach(($) => {
      $.status === "pending" && ($.status = "aborted");
    }), p = [];
  }
  function A($, L, U) {
    const W = L !== "success";
    switch (p = p.filter((k) => k !== $), l) {
      case "pending":
        break;
      case "failed":
        if (W || !s.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (L === "abort") {
      u = U, y();
      return;
    }
    if (W) {
      u = U, p.length || (o.length ? P() : y());
      return;
    }
    if (g(), x(), !s.random) {
      const k = s.resources.indexOf($.resource);
      k !== -1 && k !== s.index && (s.index = k);
    }
    l = "completed", m.forEach((k) => {
      k(U);
    });
  }
  function P() {
    if (l !== "pending")
      return;
    g();
    const $ = o.shift();
    if ($ === void 0) {
      if (p.length) {
        h = setTimeout(() => {
          g(), l === "pending" && (x(), y());
        }, s.timeout);
        return;
      }
      y();
      return;
    }
    const L = {
      status: "pending",
      resource: $,
      callback: (U, W) => {
        A(L, U, W);
      }
    };
    p.push(L), c++, h = setTimeout(P, s.rotate), e($, t, L.callback);
  }
  return setTimeout(P), w;
}
function Is(s) {
  const t = {
    ...Lo,
    ...s
  };
  let e = [];
  function i() {
    e = e.filter((a) => a().status === "pending");
  }
  function n(a, l, c) {
    const u = Ro(
      t,
      a,
      l,
      (h, p) => {
        i(), c && c(h, p);
      }
    );
    return e.push(u), u;
  }
  function r(a) {
    return e.find((l) => a(l)) || null;
  }
  return {
    query: n,
    find: r,
    setIndex: (a) => {
      t.index = a;
    },
    getIndex: () => t.index,
    cleanup: i
  };
}
function zi(s) {
  let t;
  if (typeof s.resources == "string")
    t = [s.resources];
  else if (t = s.resources, !(t instanceof Array) || !t.length)
    return null;
  return {
    // API hosts
    resources: t,
    // Root path
    path: s.path || "/",
    // URL length limit
    maxURL: s.maxURL || 500,
    // Timeout before next host is used.
    rotate: s.rotate || 750,
    // Timeout before failing query.
    timeout: s.timeout || 5e3,
    // Randomise default API end point.
    random: s.random === true,
    // Start index
    index: s.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: s.dataAfterTimeout !== false
  };
}
var We = /* @__PURE__ */ Object.create(null);
var Zt = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
];
var Se = [];
for (; Zt.length > 0; )
  Zt.length === 1 || Math.random() > 0.5 ? Se.push(Zt.shift()) : Se.push(Zt.pop());
We[""] = zi({
  resources: ["https://api.iconify.design"].concat(Se)
});
function Bn(s, t) {
  const e = zi(t);
  return e === null ? false : (We[s] = e, true);
}
function Ye(s) {
  return We[s];
}
function zo() {
  return Object.keys(We);
}
function Mn() {
}
var ri = /* @__PURE__ */ Object.create(null);
function Bo(s) {
  if (!ri[s]) {
    const t = Ye(s);
    if (!t)
      return;
    const e = Is(t), i = {
      config: t,
      redundancy: e
    };
    ri[s] = i;
  }
  return ri[s];
}
function Ls(s, t, e) {
  let i, n;
  if (typeof s == "string") {
    const r = di(s);
    if (!r)
      return e(void 0, 424), Mn;
    n = r.send;
    const o = Bo(s);
    o && (i = o.redundancy);
  } else {
    const r = zi(s);
    if (r) {
      i = Is(r);
      const o = s.resources ? s.resources[0] : "", a = di(o);
      a && (n = a.send);
    }
  }
  return !i || !n ? (e(void 0, 424), Mn) : i.query(t, n, e)().abort;
}
var jn = "iconify2";
var ue = "iconify";
var Rs = ue + "-count";
var Dn = ue + "-version";
var zs = 36e5;
var Mo = 168;
var jo = 50;
function pi(s, t) {
  try {
    return s.getItem(t);
  } catch {
  }
}
function Bi(s, t, e) {
  try {
    return s.setItem(t, e), true;
  } catch {
  }
}
function Hn(s, t) {
  try {
    s.removeItem(t);
  } catch {
  }
}
function fi(s, t) {
  return Bi(s, Rs, t.toString());
}
function mi(s) {
  return parseInt(pi(s, Rs)) || 0;
}
var kt = {
  local: true,
  session: true
};
var Bs = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
var Mi = false;
function Do(s) {
  Mi = s;
}
var $e = typeof window > "u" ? {} : window;
function Ms(s) {
  const t = s + "Storage";
  try {
    if ($e && $e[t] && typeof $e[t].length == "number")
      return $e[t];
  } catch {
  }
  kt[s] = false;
}
function js(s, t) {
  const e = Ms(s);
  if (!e)
    return;
  const i = pi(e, Dn);
  if (i !== jn) {
    if (i) {
      const a = mi(e);
      for (let l = 0; l < a; l++)
        Hn(e, ue + l.toString());
    }
    Bi(e, Dn, jn), fi(e, 0);
    return;
  }
  const n = Math.floor(Date.now() / zs) - Mo, r = (a) => {
    const l = ue + a.toString(), c = pi(e, l);
    if (typeof c == "string") {
      try {
        const u = JSON.parse(c);
        if (typeof u == "object" && typeof u.cached == "number" && u.cached > n && typeof u.provider == "string" && typeof u.data == "object" && typeof u.data.prefix == "string" && // Valid item: run callback
        t(u, a))
          return true;
      } catch {
      }
      Hn(e, l);
    }
  };
  let o = mi(e);
  for (let a = o - 1; a >= 0; a--)
    r(a) || (a === o - 1 ? (o--, fi(e, o)) : Bs[s].add(a));
}
function Ds() {
  if (!Mi) {
    Do(true);
    for (const s in kt)
      js(s, (t) => {
        const e = t.data, i = t.provider, n = e.prefix, r = mt(
          i,
          n
        );
        if (!Ri(r, e).length)
          return false;
        const o = e.lastModified || -1;
        return r.lastModifiedCached = r.lastModifiedCached ? Math.min(r.lastModifiedCached, o) : o, true;
      });
  }
}
function Ho(s, t) {
  const e = s.lastModifiedCached;
  if (
    // Matches or newer
    e && e >= t
  )
    return e === t;
  if (s.lastModifiedCached = t, e)
    for (const i in kt)
      js(i, (n) => {
        const r = n.data;
        return n.provider !== s.provider || r.prefix !== s.prefix || r.lastModified === t;
      });
  return true;
}
function Fo(s, t) {
  Mi || Ds();
  function e(i) {
    let n;
    if (!kt[i] || !(n = Ms(i)))
      return;
    const r = Bs[i];
    let o;
    if (r.size)
      r.delete(o = Array.from(r).shift());
    else if (o = mi(n), o >= jo || !fi(n, o + 1))
      return;
    const a = {
      cached: Math.floor(Date.now() / zs),
      provider: s.provider,
      data: t
    };
    return Bi(
      n,
      ue + o.toString(),
      JSON.stringify(a)
    );
  }
  t.lastModified && !Ho(s, t.lastModified) || Object.keys(t.icons).length && (t.not_found && (t = Object.assign({}, t), delete t.not_found), e("local") || e("session"));
}
function Fn() {
}
function No(s) {
  s.iconsLoaderFlag || (s.iconsLoaderFlag = true, setTimeout(() => {
    s.iconsLoaderFlag = false, Po(s);
  }));
}
function qo(s, t) {
  s.iconsToLoad ? s.iconsToLoad = s.iconsToLoad.concat(t).sort() : s.iconsToLoad = t, s.iconsQueueFlag || (s.iconsQueueFlag = true, setTimeout(() => {
    s.iconsQueueFlag = false;
    const { provider: e, prefix: i } = s, n = s.iconsToLoad;
    delete s.iconsToLoad;
    let r;
    if (!n || !(r = di(e)))
      return;
    r.prepare(e, i, n).forEach((a) => {
      Ls(e, a, (l) => {
        if (typeof l != "object")
          a.icons.forEach((c) => {
            s.missing.add(c);
          });
        else
          try {
            const c = Ri(
              s,
              l
            );
            if (!c.length)
              return;
            const u = s.pendingIcons;
            u && c.forEach((h) => {
              u.delete(h);
            }), Fo(s, l);
          } catch (c) {
            console.error(c);
          }
        No(s);
      });
    });
  }));
}
var ji = (s, t) => {
  const e = Io(s, true, Ps()), i = ko(e);
  if (!i.pending.length) {
    let l = true;
    return t && setTimeout(() => {
      l && t(
        i.loaded,
        i.missing,
        i.pending,
        Fn
      );
    }), () => {
      l = false;
    };
  }
  const n = /* @__PURE__ */ Object.create(null), r = [];
  let o, a;
  return i.pending.forEach((l) => {
    const { provider: c, prefix: u } = l;
    if (u === a && c === o)
      return;
    o = c, a = u, r.push(mt(c, u));
    const h = n[c] || (n[c] = /* @__PURE__ */ Object.create(null));
    h[u] || (h[u] = []);
  }), i.pending.forEach((l) => {
    const { provider: c, prefix: u, name: h } = l, p = mt(c, u), m = p.pendingIcons || (p.pendingIcons = /* @__PURE__ */ new Set());
    m.has(h) || (m.add(h), n[c][u].push(h));
  }), r.forEach((l) => {
    const { provider: c, prefix: u } = l;
    n[c][u].length && qo(l, n[c][u]);
  }), t ? Oo(t, i, r) : Fn;
};
var Vo = (s) => new Promise((t, e) => {
  const i = typeof s == "string" ? ge(s, true) : s;
  if (!i) {
    e(s);
    return;
  }
  ji([i || s], (n) => {
    if (n.length && i) {
      const r = ce(i);
      if (r) {
        t({
          ...be,
          ...r
        });
        return;
      }
    }
    e(s);
  });
});
function Uo(s) {
  try {
    const t = typeof s == "string" ? JSON.parse(s) : s;
    if (typeof t.body == "string")
      return {
        ...t
      };
  } catch {
  }
}
function Wo(s, t) {
  const e = typeof s == "string" ? ge(s, true, true) : null;
  if (!e) {
    const r = Uo(s);
    return {
      value: s,
      data: r
    };
  }
  const i = ce(e);
  if (i !== void 0 || !e.prefix)
    return {
      value: s,
      name: e,
      data: i
      // could be 'null' -> icon is missing
    };
  const n = ji([e], () => t(s, e, ce(e)));
  return {
    value: s,
    name: e,
    loading: n
  };
}
function oi(s) {
  return s.hasAttribute("inline");
}
var Hs = false;
try {
  Hs = navigator.vendor.indexOf("Apple") === 0;
} catch {
}
function Yo(s, t) {
  switch (t) {
    case "svg":
    case "bg":
    case "mask":
      return t;
  }
  return t !== "style" && (Hs || s.indexOf("<a") === -1) ? "svg" : s.indexOf("currentColor") === -1 ? "bg" : "mask";
}
var Go = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
var Qo = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function bi(s, t, e) {
  if (t === 1)
    return s;
  if (e = e || 100, typeof s == "number")
    return Math.ceil(s * t * e) / e;
  if (typeof s != "string")
    return s;
  const i = s.split(Go);
  if (i === null || !i.length)
    return s;
  const n = [];
  let r = i.shift(), o = Qo.test(r);
  for (; ; ) {
    if (o) {
      const a = parseFloat(r);
      isNaN(a) ? n.push(r) : n.push(Math.ceil(a * t * e) / e);
    } else
      n.push(r);
    if (r = i.shift(), r === void 0)
      return n.join("");
    o = !o;
  }
}
function Ko(s, t = "defs") {
  let e = "";
  const i = s.indexOf("<" + t);
  for (; i >= 0; ) {
    const n = s.indexOf(">", i), r = s.indexOf("</" + t);
    if (n === -1 || r === -1)
      break;
    const o = s.indexOf(">", r);
    if (o === -1)
      break;
    e += s.slice(n + 1, r).trim(), s = s.slice(0, i).trim() + s.slice(o + 1);
  }
  return {
    defs: e,
    content: s
  };
}
function Xo(s, t) {
  return s ? "<defs>" + s + "</defs>" + t : t;
}
function Zo(s, t, e) {
  const i = Ko(s);
  return Xo(i.defs, t + i.content + e);
}
var Jo = (s) => s === "unset" || s === "undefined" || s === "none";
function Fs(s, t) {
  const e = {
    ...be,
    ...s
  }, i = {
    ...As,
    ...t
  }, n = {
    left: e.left,
    top: e.top,
    width: e.width,
    height: e.height
  };
  let r = e.body;
  [e, i].forEach((v) => {
    const b = [], w = v.hFlip, y = v.vFlip;
    let x = v.rotate;
    w ? y ? x += 2 : (b.push(
      "translate(" + (n.width + n.left).toString() + " " + (0 - n.top).toString() + ")"
    ), b.push("scale(-1 1)"), n.top = n.left = 0) : y && (b.push(
      "translate(" + (0 - n.left).toString() + " " + (n.height + n.top).toString() + ")"
    ), b.push("scale(1 -1)"), n.top = n.left = 0);
    let A;
    switch (x < 0 && (x -= Math.floor(x / 4) * 4), x = x % 4, x) {
      case 1:
        A = n.height / 2 + n.top, b.unshift(
          "rotate(90 " + A.toString() + " " + A.toString() + ")"
        );
        break;
      case 2:
        b.unshift(
          "rotate(180 " + (n.width / 2 + n.left).toString() + " " + (n.height / 2 + n.top).toString() + ")"
        );
        break;
      case 3:
        A = n.width / 2 + n.left, b.unshift(
          "rotate(-90 " + A.toString() + " " + A.toString() + ")"
        );
        break;
    }
    x % 2 === 1 && (n.left !== n.top && (A = n.left, n.left = n.top, n.top = A), n.width !== n.height && (A = n.width, n.width = n.height, n.height = A)), b.length && (r = Zo(
      r,
      '<g transform="' + b.join(" ") + '">',
      "</g>"
    ));
  });
  const o = i.width, a = i.height, l = n.width, c = n.height;
  let u, h;
  o === null ? (h = a === null ? "1em" : a === "auto" ? c : a, u = bi(h, l / c)) : (u = o === "auto" ? l : o, h = a === null ? bi(u, c / l) : a === "auto" ? c : a);
  const p = {}, m = (v, b) => {
    Jo(b) || (p[v] = b.toString());
  };
  m("width", u), m("height", h);
  const g = [n.left, n.top, l, c];
  return p.viewBox = g.join(" "), {
    attributes: p,
    viewBox: g,
    body: r
  };
}
function Di(s, t) {
  let e = s.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const i in t)
    e += " " + i + '="' + t[i] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + e + ">" + s + "</svg>";
}
function ta(s) {
  return s.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function ea(s) {
  return "data:image/svg+xml," + ta(s);
}
function Ns(s) {
  return 'url("' + ea(s) + '")';
}
var ia = () => {
  let s;
  try {
    if (s = fetch, typeof s == "function")
      return s;
  } catch {
  }
};
var ze = ia();
function na(s) {
  ze = s;
}
function sa() {
  return ze;
}
function ra(s, t) {
  const e = Ye(s);
  if (!e)
    return 0;
  let i;
  if (!e.maxURL)
    i = 0;
  else {
    let n = 0;
    e.resources.forEach((o) => {
      n = Math.max(n, o.length);
    });
    const r = t + ".json?icons=";
    i = e.maxURL - n - e.path.length - r.length;
  }
  return i;
}
function oa(s) {
  return s === 404;
}
var aa = (s, t, e) => {
  const i = [], n = ra(s, t), r = "icons";
  let o = {
    type: r,
    provider: s,
    prefix: t,
    icons: []
  }, a = 0;
  return e.forEach((l, c) => {
    a += l.length + 1, a >= n && c > 0 && (i.push(o), o = {
      type: r,
      provider: s,
      prefix: t,
      icons: []
    }, a = l.length), o.icons.push(l);
  }), i.push(o), i;
};
function la(s) {
  if (typeof s == "string") {
    const t = Ye(s);
    if (t)
      return t.path;
  }
  return "/";
}
var ca = (s, t, e) => {
  if (!ze) {
    e("abort", 424);
    return;
  }
  let i = la(t.provider);
  switch (t.type) {
    case "icons": {
      const r = t.prefix, a = t.icons.join(","), l = new URLSearchParams({
        icons: a
      });
      i += r + ".json?" + l.toString();
      break;
    }
    case "custom": {
      const r = t.uri;
      i += r.slice(0, 1) === "/" ? r.slice(1) : r;
      break;
    }
    default:
      e("abort", 400);
      return;
  }
  let n = 503;
  ze(s + i).then((r) => {
    const o = r.status;
    if (o !== 200) {
      setTimeout(() => {
        e(oa(o) ? "abort" : "next", o);
      });
      return;
    }
    return n = 501, r.json();
  }).then((r) => {
    if (typeof r != "object" || r === null) {
      setTimeout(() => {
        r === 404 ? e("abort", r) : e("next", n);
      });
      return;
    }
    setTimeout(() => {
      e("success", r);
    });
  }).catch(() => {
    e("next", n);
  });
};
var ua = {
  prepare: aa,
  send: ca
};
function Nn(s, t) {
  switch (s) {
    case "local":
    case "session":
      kt[s] = t;
      break;
    case "all":
      for (const e in kt)
        kt[e] = t;
      break;
  }
}
var ai = "data-style";
var qs = "";
function ha(s) {
  qs = s;
}
function qn(s, t) {
  let e = Array.from(s.childNodes).find((i) => i.hasAttribute && i.hasAttribute(ai));
  e || (e = document.createElement("style"), e.setAttribute(ai, ai), s.appendChild(e)), e.textContent = ":host{display:inline-block;vertical-align:" + (t ? "-0.125em" : "0") + "}span,svg{display:block}" + qs;
}
function Vs() {
  zn("", ua), Ps(true);
  let s;
  try {
    s = window;
  } catch {
  }
  if (s) {
    if (Ds(), s.IconifyPreload !== void 0) {
      const e = s.IconifyPreload, i = "Invalid IconifyPreload syntax.";
      typeof e == "object" && e !== null && (e instanceof Array ? e : [e]).forEach((n) => {
        try {
          (typeof n != "object" || n === null || n instanceof Array || // Check for 'icons' and 'prefix'
          typeof n.icons != "object" || typeof n.prefix != "string" || // Add icon set
          !Ln(n)) && console.error(i);
        } catch {
          console.error(i);
        }
      });
    }
    if (s.IconifyProviders !== void 0) {
      const e = s.IconifyProviders;
      if (typeof e == "object" && e !== null)
        for (const i in e) {
          const n = "IconifyProviders[" + i + "] is invalid.";
          try {
            const r = e[i];
            if (typeof r != "object" || !r || r.resources === void 0)
              continue;
            Bn(i, r) || console.error(n);
          } catch {
            console.error(n);
          }
        }
    }
  }
  return {
    enableCache: (e) => Nn(e, true),
    disableCache: (e) => Nn(e, false),
    iconLoaded: Rn,
    iconExists: Rn,
    getIcon: Eo,
    listIcons: So,
    addIcon: Ts,
    addCollection: Ln,
    calculateSize: bi,
    buildIcon: Fs,
    iconToHTML: Di,
    svgToURL: Ns,
    loadIcons: ji,
    loadIcon: Vo,
    addAPIProvider: Bn,
    appendCustomStyle: ha,
    _api: {
      getAPIConfig: Ye,
      setAPIModule: zn,
      sendAPIQuery: Ls,
      setFetch: na,
      getFetch: sa,
      listAPIProviders: zo
    }
  };
}
var gi = {
  "background-color": "currentColor"
};
var Us = {
  "background-color": "transparent"
};
var Vn = {
  image: "var(--svg)",
  repeat: "no-repeat",
  size: "100% 100%"
};
var Un = {
  "-webkit-mask": gi,
  mask: gi,
  background: Us
};
for (const s in Un) {
  const t = Un[s];
  for (const e in Vn)
    t[s + "-" + e] = Vn[e];
}
function Wn(s) {
  return s ? s + (s.match(/^[-0-9.]+$/) ? "px" : "") : "inherit";
}
function da(s, t, e) {
  const i = document.createElement("span");
  let n = s.body;
  n.indexOf("<a") !== -1 && (n += "<!-- " + Date.now() + " -->");
  const r = s.attributes, o = Di(n, {
    ...r,
    width: t.width + "",
    height: t.height + ""
  }), a = Ns(o), l = i.style, c = {
    "--svg": a,
    width: Wn(r.width),
    height: Wn(r.height),
    ...e ? gi : Us
  };
  for (const u in c)
    l.setProperty(u, c[u]);
  return i;
}
var ne;
function pa() {
  try {
    ne = window.trustedTypes.createPolicy("iconify", {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      createHTML: (s) => s
    });
  } catch {
    ne = null;
  }
}
function fa(s) {
  return ne === void 0 && pa(), ne ? ne.createHTML(s) : s;
}
function ma(s) {
  const t = document.createElement("span"), e = s.attributes;
  let i = "";
  e.width || (i = "width: inherit;"), e.height || (i += "height: inherit;"), i && (e.style = i);
  const n = Di(s.body, e);
  return t.innerHTML = fa(n), t.firstChild;
}
function vi(s) {
  return Array.from(s.childNodes).find((t) => {
    const e = t.tagName && t.tagName.toUpperCase();
    return e === "SPAN" || e === "SVG";
  });
}
function Yn(s, t) {
  const e = t.icon.data, i = t.customisations, n = Fs(e, i);
  i.preserveAspectRatio && (n.attributes.preserveAspectRatio = i.preserveAspectRatio);
  const r = t.renderedMode;
  let o;
  switch (r) {
    case "svg":
      o = ma(n);
      break;
    default:
      o = da(n, {
        ...be,
        ...e
      }, r === "mask");
  }
  const a = vi(s);
  a ? o.tagName === "SPAN" && a.tagName === o.tagName ? a.setAttribute("style", o.getAttribute("style")) : s.replaceChild(o, a) : s.appendChild(o);
}
function Gn(s, t, e) {
  const i = e && (e.rendered ? e : e.lastRender);
  return {
    rendered: false,
    inline: t,
    icon: s,
    lastRender: i
  };
}
function ba(s = "iconify-icon") {
  let t, e;
  try {
    t = window.customElements, e = window.HTMLElement;
  } catch {
    return;
  }
  if (!t || !e)
    return;
  const i = t.get(s);
  if (i)
    return i;
  const n = [
    // Icon
    "icon",
    // Mode
    "mode",
    "inline",
    "observe",
    // Customisations
    "width",
    "height",
    "rotate",
    "flip"
  ], r = class extends e {
    /**
     * Constructor
     */
    constructor() {
      super();
      ut(this, "_shadowRoot");
      ut(this, "_initialised", false);
      ut(this, "_state");
      ut(this, "_checkQueued", false);
      ut(this, "_connected", false);
      ut(this, "_observer", null);
      ut(this, "_visible", true);
      const l = this._shadowRoot = this.attachShadow({
        mode: "open"
      }), c = oi(this);
      qn(l, c), this._state = Gn({
        value: ""
      }, c), this._queueCheck();
    }
    /**
     * Connected to DOM
     */
    connectedCallback() {
      this._connected = true, this.startObserver();
    }
    /**
     * Disconnected from DOM
     */
    disconnectedCallback() {
      this._connected = false, this.stopObserver();
    }
    /**
     * Observed attributes
     */
    static get observedAttributes() {
      return n.slice(0);
    }
    /**
     * Observed properties that are different from attributes
     *
     * Experimental! Need to test with various frameworks that support it
     */
    /*
    static get properties() {
        return {
            inline: {
                type: Boolean,
                reflect: true,
            },
            // Not listing other attributes because they are strings or combination
            // of string and another type. Cannot have multiple types
        };
    }
    */
    /**
     * Attribute has changed
     */
    attributeChangedCallback(l) {
      switch (l) {
        case "inline": {
          const c = oi(this), u = this._state;
          c !== u.inline && (u.inline = c, qn(this._shadowRoot, c));
          break;
        }
        case "observer": {
          this.observer ? this.startObserver() : this.stopObserver();
          break;
        }
        default:
          this._queueCheck();
      }
    }
    /**
     * Get/set icon
     */
    get icon() {
      const l = this.getAttribute("icon");
      if (l && l.slice(0, 1) === "{")
        try {
          return JSON.parse(l);
        } catch {
        }
      return l;
    }
    set icon(l) {
      typeof l == "object" && (l = JSON.stringify(l)), this.setAttribute("icon", l);
    }
    /**
     * Get/set inline
     */
    get inline() {
      return oi(this);
    }
    set inline(l) {
      l ? this.setAttribute("inline", "true") : this.removeAttribute("inline");
    }
    /**
     * Get/set observer
     */
    get observer() {
      return this.hasAttribute("observer");
    }
    set observer(l) {
      l ? this.setAttribute("observer", "true") : this.removeAttribute("observer");
    }
    /**
     * Restart animation
     */
    restartAnimation() {
      const l = this._state;
      if (l.rendered) {
        const c = this._shadowRoot;
        if (l.renderedMode === "svg")
          try {
            c.lastChild.setCurrentTime(0);
            return;
          } catch {
          }
        Yn(c, l);
      }
    }
    /**
     * Get status
     */
    get status() {
      const l = this._state;
      return l.rendered ? "rendered" : l.icon.data === null ? "failed" : "loading";
    }
    /**
     * Queue attributes re-check
     */
    _queueCheck() {
      this._checkQueued || (this._checkQueued = true, setTimeout(() => {
        this._check();
      }));
    }
    /**
     * Check for changes
     */
    _check() {
      if (!this._checkQueued)
        return;
      this._checkQueued = false;
      const l = this._state, c = this.getAttribute("icon");
      if (c !== l.icon.value) {
        this._iconChanged(c);
        return;
      }
      if (!l.rendered || !this._visible)
        return;
      const u = this.getAttribute("mode"), h = On(this);
      (l.attrMode !== u || yo(l.customisations, h) || !vi(this._shadowRoot)) && this._renderIcon(l.icon, h, u);
    }
    /**
     * Icon value has changed
     */
    _iconChanged(l) {
      const c = Wo(l, (u, h, p) => {
        const m = this._state;
        if (m.rendered || this.getAttribute("icon") !== u)
          return;
        const g = {
          value: u,
          name: h,
          data: p
        };
        g.data ? this._gotIconData(g) : m.icon = g;
      });
      c.data ? this._gotIconData(c) : this._state = Gn(c, this._state.inline, this._state);
    }
    /**
     * Force render icon on state change
     */
    _forceRender() {
      if (!this._visible) {
        const l = vi(this._shadowRoot);
        l && this._shadowRoot.removeChild(l);
        return;
      }
      this._queueCheck();
    }
    /**
     * Got new icon data, icon is ready to (re)render
     */
    _gotIconData(l) {
      this._checkQueued = false, this._renderIcon(l, On(this), this.getAttribute("mode"));
    }
    /**
     * Re-render based on icon data
     */
    _renderIcon(l, c, u) {
      const h = Yo(l.data.body, u), p = this._state.inline;
      Yn(this._shadowRoot, this._state = {
        rendered: true,
        icon: l,
        inline: p,
        customisations: c,
        attrMode: u,
        renderedMode: h
      });
    }
    /**
     * Start observer
     */
    startObserver() {
      if (!this._observer)
        try {
          this._observer = new IntersectionObserver((l) => {
            const c = l.some((u) => u.isIntersecting);
            c !== this._visible && (this._visible = c, this._forceRender());
          }), this._observer.observe(this);
        } catch {
          if (this._observer) {
            try {
              this._observer.disconnect();
            } catch {
            }
            this._observer = null;
          }
        }
    }
    /**
     * Stop observer
     */
    stopObserver() {
      this._observer && (this._observer.disconnect(), this._observer = null, this._visible = true, this._connected && this._forceRender());
    }
  };
  n.forEach((a) => {
    a in r.prototype || Object.defineProperty(r.prototype, a, {
      get: function() {
        return this.getAttribute(a);
      },
      set: function(l) {
        l !== null ? this.setAttribute(a, l) : this.removeAttribute(a);
      }
    });
  });
  const o = Vs();
  for (const a in o)
    r[a] = r.prototype[a] = o[a];
  return t.define(s, r), r;
}
var ga = ba() || Vs();
var {
  enableCache: _l,
  disableCache: wl,
  iconLoaded: xl,
  iconExists: $l,
  // deprecated, kept to avoid breaking changes
  getIcon: Cl,
  listIcons: Al,
  addIcon: Sl,
  addCollection: va,
  calculateSize: El,
  buildIcon: kl,
  iconToHTML: Pl,
  svgToURL: Tl,
  loadIcons: ya,
  loadIcon: Ol,
  addAPIProvider: Il,
  _api: Ll
} = ga;
var _a = S`
  ::-webkit-scrollbar {
    width: 0.4rem;
    height: 0.4rem;
    overflow: hidden;
  }

  ::-webkit-scrollbar-thumb {
    border-radius: 0.25rem;
    background-color: var(
      --bim-scrollbar--c,
      color-mix(in lab, var(--bim-ui_main-base), white 15%)
    );
  }

  ::-webkit-scrollbar-track {
    background-color: var(--bim-scrollbar--bgc, var(--bim-ui_bg-base));
  }
`;
var wa = S`
  :root {
    /* Grayscale Colors */
    --bim-ui_gray-0: hsl(210 10% 5%);
    --bim-ui_gray-1: hsl(210 10% 10%);
    --bim-ui_gray-2: hsl(210 10% 20%);
    --bim-ui_gray-3: hsl(210 10% 30%);
    --bim-ui_gray-4: hsl(210 10% 40%);
    --bim-ui_gray-5: hsl(210 10% 50%);
    --bim-ui_gray-6: hsl(210 10% 60%);
    --bim-ui_gray-7: hsl(210 10% 70%);
    --bim-ui_gray-8: hsl(210 10% 80%);
    --bim-ui_gray-9: hsl(210 10% 90%);
    --bim-ui_gray-10: hsl(210 10% 95%);

    /* Brand Colors */
    --bim-ui_main-base: #6528d7;
    --bim-ui_accent-base: #bcf124;

    /* Brand Colors Contrasts */
    --bim-ui_main-contrast: var(--bim-ui_gray-10);
    --bim-ui_accent-contrast: var(--bim-ui_gray-0);

    /* Sizes */
    --bim-ui_size-4xs: 0.375rem;
    --bim-ui_size-3xs: 0.5rem;
    --bim-ui_size-2xs: 0.625rem;
    --bim-ui_size-xs: 0.75rem;
    --bim-ui_size-sm: 0.875rem;
    --bim-ui_size-base: 1rem;
    --bim-ui_size-lg: 1.125rem;
    --bim-ui_size-xl: 1.25rem;
    --bim-ui_size-2xl: 1.375rem;
    --bim-ui_size-3xl: 1.5rem;
    --bim-ui_size-4xl: 1.625rem;
    --bim-ui_size-5xl: 1.75rem;
    --bim-ui_size-6xl: 1.875rem;
    --bim-ui_size-7xl: 2rem;
    --bim-ui_size-8xl: 2.125rem;
    --bim-ui_size-9xl: 2.25rem;
  }

  /* Background Colors */
  @media (prefers-color-scheme: dark) {
    :root {
      --bim-ui_bg-base: var(--bim-ui_gray-0);
      --bim-ui_bg-contrast-10: var(--bim-ui_gray-1);
      --bim-ui_bg-contrast-20: var(--bim-ui_gray-2);
      --bim-ui_bg-contrast-30: var(--bim-ui_gray-3);
      --bim-ui_bg-contrast-40: var(--bim-ui_gray-4);
      --bim-ui_bg-contrast-60: var(--bim-ui_gray-6);
      --bim-ui_bg-contrast-80: var(--bim-ui_gray-8);
      --bim-ui_bg-contrast-100: var(--bim-ui_gray-10);
    }
  }

  @media (prefers-color-scheme: light) {
    :root {
      --bim-ui_bg-base: var(--bim-ui_gray-10);
      --bim-ui_bg-contrast-10: var(--bim-ui_gray-9);
      --bim-ui_bg-contrast-20: var(--bim-ui_gray-8);
      --bim-ui_bg-contrast-30: var(--bim-ui_gray-7);
      --bim-ui_bg-contrast-40: var(--bim-ui_gray-6);
      --bim-ui_bg-contrast-60: var(--bim-ui_gray-4);
      --bim-ui_bg-contrast-80: var(--bim-ui_gray-2);
      --bim-ui_bg-contrast-100: var(--bim-ui_gray-0);
      --bim-ui_accent-base: #6528d7;
    }
  }

  .theme-transition-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    filter: drop-shadow(0 0 10px var(--bim-ui_bg-base));
    z-index: 9999;
  }

  .theme-transition-overlay > div {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: var(--bim-ui_bg-base);
  }

  html.bim-ui-dark {
    --bim-ui_bg-base: var(--bim-ui_gray-0);
    --bim-ui_bg-contrast-10: var(--bim-ui_gray-1);
    --bim-ui_bg-contrast-20: var(--bim-ui_gray-2);
    --bim-ui_bg-contrast-30: var(--bim-ui_gray-3);
    --bim-ui_bg-contrast-40: var(--bim-ui_gray-4);
    --bim-ui_bg-contrast-60: var(--bim-ui_gray-6);
    --bim-ui_bg-contrast-80: var(--bim-ui_gray-8);
    --bim-ui_bg-contrast-100: var(--bim-ui_gray-10);
  }

  html.bim-ui-light {
    --bim-ui_bg-base: var(--bim-ui_gray-10);
    --bim-ui_bg-contrast-10: var(--bim-ui_gray-9);
    --bim-ui_bg-contrast-20: var(--bim-ui_gray-8);
    --bim-ui_bg-contrast-30: var(--bim-ui_gray-7);
    --bim-ui_bg-contrast-40: var(--bim-ui_gray-6);
    --bim-ui_bg-contrast-60: var(--bim-ui_gray-4);
    --bim-ui_bg-contrast-80: var(--bim-ui_gray-2);
    --bim-ui_bg-contrast-100: var(--bim-ui_gray-0);
    --bim-ui_accent-base: #6528d7;
  }

  @keyframes toggleOverlay {
    0%,
    99% {
      display: block;
    }

    100% {
      display: none;
    }
  }

  @keyframes toggleThemeAnimation {
    0% {
      clip-path: circle(0% at center top);
    }
    45%,
    55% {
      clip-path: circle(150% at center center);
    }
    100% {
      clip-path: circle(0% at center bottom);
    }
  }

  [data-context-dialog]::backdrop {
    background-color: transparent;
  }
`;
var xt = {
  scrollbar: _a,
  globalStyles: wa
};
var _ = class _2 {
  static set config(t) {
    this._config = { ..._2._config, ...t };
  }
  static get config() {
    return _2._config;
  }
  static addGlobalStyles() {
    let t = document.querySelector("style[id='bim-ui']");
    if (t)
      return;
    t = document.createElement("style"), t.id = "bim-ui", t.textContent = xt.globalStyles.cssText;
    const e = document.head.firstChild;
    e ? document.head.insertBefore(t, e) : document.head.append(t);
  }
  static preloadIcons(t, e = false) {
    ya(t, (i, n, r) => {
      e && (console.log("Icons loaded:", i), n.length && console.warn("Icons missing:", n), r.length && console.info("Icons pending:", r));
    });
  }
  static addIconsCollection(t, e) {
    va({
      prefix: (e == null ? void 0 : e.prefix) ?? "bim",
      icons: t,
      width: 24,
      height: 24
    });
  }
  static defineCustomElement(t, e) {
    customElements.get(t) || customElements.define(t, e);
  }
  /**
   * @deprecated Use `Manager.init()` instead.
   */
  static registerComponents() {
    _2.init();
  }
  /**
   * Initializes the BIM UI library by defining custom elements.
   * It ensures that all necessary styles and custom elements are registered for use in BIM UI components.
   *
   * @example
   * ```typescript
   * import { Manager } from "@thatopen/ui";
   * Manager.init();
   * ```
   */
  static init(t = "", e = true) {
    _2.addGlobalStyles(), _2.defineCustomElement("bim-button", Ea), _2.defineCustomElement("bim-checkbox", bt), _2.defineCustomElement("bim-color-input", tt), _2.defineCustomElement("bim-context-menu", Ee), _2.defineCustomElement("bim-dropdown", H), _2.defineCustomElement("bim-grid", de), _2.defineCustomElement("bim-icon", _i), _2.defineCustomElement("bim-input", It), _2.defineCustomElement("bim-label", gt), _2.defineCustomElement("bim-number-input", z), _2.defineCustomElement("bim-option", T), _2.defineCustomElement("bim-panel", ot), _2.defineCustomElement("bim-panel-section", vt), _2.defineCustomElement("bim-selector", yt), _2.defineCustomElement("bim-table", B), _2.defineCustomElement("bim-tabs", Y), _2.defineCustomElement("bim-tab", R), _2.defineCustomElement("bim-table-cell", Me), _2.defineCustomElement("bim-table-children", xi), _2.defineCustomElement("bim-table-group", je), _2.defineCustomElement("bim-table-row", at), _2.defineCustomElement("bim-text-input", M), _2.defineCustomElement("bim-toolbar", Yt), _2.defineCustomElement("bim-toolbar-group", Wt), _2.defineCustomElement(
      "bim-toolbar-section",
      _t
    ), _2.defineCustomElement("bim-viewport", De), _2.defineCustomElement("bim-tooltip", fl), e && this.animateOnLoad(t);
  }
  static newRandomId() {
    const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let e = "";
    for (let i = 0; i < 10; i++) {
      const n = Math.floor(Math.random() * t.length);
      e += t.charAt(n);
    }
    return e;
  }
  static animateOnLoad(t = "") {
    const e = `
      bim-input,
      bim-button,
      bim-checkbox,
      bim-selector,
      bim-label,
      bim-table-row,
      bim-panel-section,
      bim-table-children .branch-vertical,
      .switchers
    `, i = [];
    function n(r, o = document, a = /* @__PURE__ */ new Set()) {
      const l = [];
      return Array.from(o.querySelectorAll(r)).forEach((h) => {
        a.has(h) || (a.add(h), l.push(h));
      }), Array.from(
        o.querySelectorAll("*")
      ).filter((h) => h.shadowRoot).forEach((h) => {
        a.has(h) || (a.add(h), l.push(
          ...n(r, h.shadowRoot, a)
        ));
      }), l;
    }
    requestAnimationFrame(() => {
      n(
        t || e
      ).forEach((a) => {
        const l = a;
        let c = "auto";
        c = window.getComputedStyle(l).getPropertyValue("transition"), l.style.setProperty("opacity", "0"), l.style.setProperty("transition", "none"), requestAnimationFrame(() => {
          l.style.setProperty("transition", c);
        }), i.push(l);
      });
      const o = () => {
        i.forEach((a) => {
          const l = a, c = (l.getBoundingClientRect().x + l.getBoundingClientRect().y) / (window.innerWidth + window.innerHeight), u = window.getComputedStyle(l).getPropertyValue("transform"), h = 400, p = 200 + c * 1e3;
          l.animate(
            [
              {
                transform: "translateY(-20px)",
                opacity: "0"
              },
              {
                transform: "translateY(0)",
                opacity: "1"
              }
            ],
            {
              duration: h,
              easing: "ease-in-out",
              delay: p
            }
          ), setTimeout(() => {
            l.style.removeProperty("opacity"), u !== "none" ? l.style.setProperty("transform", u) : l.style.removeProperty("transform");
          }, p + h);
        });
      };
      document.readyState === "complete" ? o() : window.addEventListener("load", o);
    });
  }
  static toggleTheme(t = true) {
    const e = document.querySelector("html");
    if (!e)
      return;
    const i = () => {
      e.classList.contains("bim-ui-dark") ? e.classList.replace("bim-ui-dark", "bim-ui-light") : e.classList.contains("bim-ui-light") ? e.classList.replace("bim-ui-light", "bim-ui-dark") : e.classList.add("bim-ui-light");
    };
    if (t) {
      const r = document.createElement("div");
      r.classList.add("theme-transition-overlay");
      const o = document.createElement("div");
      r.appendChild(o), o.style.setProperty(
        "transition",
        `background-color ${1e3 / 3200}s`
      ), document.body.appendChild(r), r.style.setProperty(
        "animation",
        `toggleOverlay ${1e3 / 1e3}s ease-in forwards`
      ), o.style.setProperty(
        "animation",
        `toggleThemeAnimation ${1e3 / 1e3}s ease forwards`
      ), setTimeout(() => {
        i();
      }, 1e3 / 4), setTimeout(() => {
        document.body.querySelectorAll(
          ".theme-transition-overlay"
        ).forEach((l) => {
          document.body.removeChild(l);
        });
      }, 1e3);
    } else
      i();
  }
};
_._config = {
  sectionLabelOnVerticalToolbar: false
  // draggableToolbars: true,
  // draggablePanels: true,
};
var he = _;
var Ut = class extends C {
  constructor() {
    super(...arguments), this._lazyLoadObserver = null, this._visibleElements = [], this.ELEMENTS_BEFORE_OBSERVER = 20, this.useObserver = false, this.elements = /* @__PURE__ */ new Set(), this.observe = (t) => {
      if (!this.useObserver)
        return;
      for (const i of t)
        this.elements.add(i);
      const e = t.slice(this.ELEMENTS_BEFORE_OBSERVER);
      for (const i of e)
        i.remove();
      this.observeLastElement();
    };
  }
  set visibleElements(t) {
    this._visibleElements = this.useObserver ? t : [], this.requestUpdate();
  }
  get visibleElements() {
    return this._visibleElements;
  }
  getLazyObserver() {
    if (!this.useObserver)
      return null;
    if (this._lazyLoadObserver)
      return this._lazyLoadObserver;
    const t = new IntersectionObserver(
      (e) => {
        const i = e[0];
        if (!i.isIntersecting)
          return;
        const n = i.target;
        t.unobserve(n);
        const r = this.ELEMENTS_BEFORE_OBSERVER + this.visibleElements.length, o = [...this.elements][r];
        o && (this.visibleElements = [...this.visibleElements, o], t.observe(o));
      },
      { threshold: 0.5 }
    );
    return t;
  }
  observeLastElement() {
    const t = this.getLazyObserver();
    if (!t)
      return;
    const e = this.ELEMENTS_BEFORE_OBSERVER + this.visibleElements.length - 1, i = [...this.elements][e];
    i && t.observe(i);
  }
  resetVisibleElements() {
    const t = this.getLazyObserver();
    if (t) {
      for (const e of this.elements)
        t.unobserve(e);
      this.visibleElements = [], this.observeLastElement();
    }
  }
  /**
   * Creates a new UI component instance based on the provided template and initial state.
   *
   * @template T - The type of the UI component element.
   * @template S - The type of the component state.
   *
   * @param template - The component template function (stateless or stateful).
   * @param initialState - The initial state of the component (optional for stateless components).
   * @returns The created UI component element or an array containing the element and a function to update its state.
   */
  static create(t, e) {
    const i = document.createDocumentFragment();
    if (t.length === 0)
      return ci(t(), i), i.firstElementChild;
    if (!e)
      throw new Error(
        "UIComponent: Initial state is required for statefull components."
      );
    let n = e;
    const r = t, o = (c) => (n = { ...n, ...c }, ci(r(n, o), i), n);
    o(e);
    const a = () => n;
    return [i.firstElementChild, o, a];
  }
};
var Be = (s, t = {}, e = true) => {
  let i = {};
  for (const n of s.children) {
    const r = n, o = r.getAttribute("name") || r.getAttribute("label"), a = o ? t[o] : void 0;
    if (o) {
      if ("value" in r && typeof r.value < "u" && r.value !== null) {
        const l = r.value;
        if (typeof l == "object" && !Array.isArray(l) && Object.keys(l).length === 0)
          continue;
        i[o] = a ? a(r.value) : r.value;
      } else if (e) {
        const l = Be(r, t);
        if (Object.keys(l).length === 0)
          continue;
        i[o] = a ? a(l) : l;
      }
    } else
      e && (i = { ...i, ...Be(r, t) });
  }
  return i;
};
var Ge = (s) => s === "true" || s === "false" ? s === "true" : s && !isNaN(Number(s)) && s.trim() !== "" ? Number(s) : s;
var xa = [">=", "<=", "=", ">", "<", "?", "/", "#"];
function Qn(s) {
  const t = xa.find(
    (a) => s.split(a).length === 2
  ), e = s.split(t).map((a) => a.trim()), [i, n] = e, r = n.startsWith("'") && n.endsWith("'") ? n.replace(/'/g, "") : Ge(n);
  return { key: i, condition: t, value: r };
}
var yi = (s) => {
  try {
    const t = [], e = s.split(/&(?![^()]*\))/).map((i) => i.trim());
    for (const i of e) {
      const n = !i.startsWith("(") && !i.endsWith(")"), r = i.startsWith("(") && i.endsWith(")");
      if (n) {
        const o = Qn(i);
        t.push(o);
      }
      if (r) {
        const c = {
          operator: "&",
          queries: i.replace(/^(\()|(\))$/g, "").split("&").map((u) => u.trim()).map((u, h) => {
            const p = Qn(u);
            return h > 0 && (p.operator = "&"), p;
          })
        };
        t.push(c);
      }
    }
    return t;
  } catch {
    return null;
  }
};
var Kn = (s, t, e) => {
  let i = false;
  switch (t) {
    case "=":
      i = s === e;
      break;
    case "?":
      i = String(s).includes(String(e));
      break;
    case "<":
      (typeof s == "number" || typeof e == "number") && (i = s < e);
      break;
    case "<=":
      (typeof s == "number" || typeof e == "number") && (i = s <= e);
      break;
    case ">":
      (typeof s == "number" || typeof e == "number") && (i = s > e);
      break;
    case ">=":
      (typeof s == "number" || typeof e == "number") && (i = s >= e);
      break;
    case "/":
      i = String(s).startsWith(String(e));
      break;
  }
  return i;
};
var $a = Object.defineProperty;
var Ca = Object.getOwnPropertyDescriptor;
var Ws = (s, t, e, i) => {
  for (var n = Ca(t, e), r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (n = o(t, e, n) || n);
  return n && $a(t, e, n), n;
};
var O;
var Hi = (O = class extends C {
  constructor() {
    super(...arguments), this._previousContainer = null, this._visible = false;
  }
  get placement() {
    return this._placement;
  }
  set placement(t) {
    this._placement = t, this.updatePosition();
  }
  static removeMenus() {
    for (const t of [...O.dialog.children])
      t instanceof O && (t.remove(), t.visible = false);
    setTimeout(() => {
      O.dialog.close(), O.dialog.remove();
    }, 310);
  }
  get visible() {
    return this._visible;
  }
  set visible(t) {
    this._visible = t, t ? (O.dialog.parentElement || document.body.append(O.dialog), this._previousContainer = this.parentElement, O.dialog.style.top = `${window.scrollY || document.documentElement.scrollTop}px`, this.style.setProperty("display", "flex"), O.dialog.append(this), O.dialog.showModal(), this.updatePosition(), this.dispatchEvent(new Event("visible"))) : setTimeout(() => {
      var e;
      (e = this._previousContainer) == null || e.append(this), this._previousContainer = null, this.style.setProperty("display", "none"), this.dispatchEvent(new Event("hidden"));
    }, 310);
  }
  /**
   * Asynchronously updates the position of the context menu relative to a target element.
   * If no target element is provided, it attempts to use the parent node as the target.
   * The position is calculated using the `computePosition` function from `@floating-ui/dom`,
   * which considers various adjustments like offset, inline positioning, flipping, and shifting
   * to ensure the context menu is properly placed relative to the target element.
   *
   * @param [target] - The target element relative to which the context menu should be positioned.
   *                                 If not provided, the parent node is used as the target.
   * @returns A promise that resolves once the position has been updated. This method
   *                          does not explicitly return a value but updates the context menu's style
   *                          properties to position it on the screen.
   */
  async updatePosition() {
    if (!(this.visible && this._previousContainer))
      return;
    const t = this.placement ?? "right", e = await Pi(this._previousContainer, this, {
      placement: t,
      middleware: [$i(10), ki(), Ei(), Si({ padding: 5 })]
    }), { x: i, y: n } = e;
    this.style.left = `${i}px`, this.style.top = `${n}px`;
  }
  connectedCallback() {
    super.connectedCallback(), this.visible ? (this.style.setProperty("width", "auto"), this.style.setProperty("height", "auto")) : (this.style.setProperty("display", "none"), this.style.setProperty("width", "0"), this.style.setProperty("height", "0"));
  }
  render() {
    return f` <slot></slot> `;
  }
}, O.styles = [
  xt.scrollbar,
  S`
      :host {
        pointer-events: auto;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 999;
        overflow: auto;
        max-height: 20rem;
        min-width: 3rem;
        flex-direction: column;
        box-shadow: 1px 2px 8px 2px rgba(0, 0, 0, 0.15);
        padding: 0.5rem;
        border-radius: var(--bim-ui_size-4xs);
        display: flex;
        transform-origin: top left;
        transform: scale(1);
        clip-path: circle(150% at top left);
        background-color: var(--bim-ui_bg-contrast-20);
        transition:
          clip-path 0.2s cubic-bezier(0.72, 0.1, 0.43, 0.93),
          transform 0.3s cubic-bezier(0.72, 0.1, 0.45, 2.35);
      }

      :host(:not([visible])) {
        transform: scale(0.8);
        clip-path: circle(0 at top left);
      }
    `
], O.dialog = Ut.create(() => f` <dialog
      @click=${(e) => {
  e.target === O.dialog && O.removeMenus();
}}
      @cancel=${() => O.removeMenus()}
      data-context-dialog
      style="
      width: 0;
      height: 0;
      position: relative;
      padding: 0;
      border: none;
      outline: none;
      margin: none;
      overflow: visible;
      background-color: transparent;
    "
    ></dialog>`), O);
Ws([
  d({ type: String, reflect: true })
], Hi.prototype, "placement");
Ws([
  d({ type: Boolean, reflect: true })
], Hi.prototype, "visible");
var Ee = Hi;
var Aa = Object.defineProperty;
var Sa = Object.getOwnPropertyDescriptor;
var G = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? Sa(t, e) : t, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (n = (i ? o(t, e, n) : o(n)) || n);
  return i && n && Aa(t, e, n), n;
};
var Pt;
var N = (Pt = class extends C {
  constructor() {
    super(), this.labelHidden = false, this.active = false, this.disabled = false, this.vertical = false, this.tooltipVisible = false, this._stateBeforeLoading = {
      disabled: false,
      icon: ""
    }, this._loading = false, this._parent = Vt(), this._tooltip = Vt(), this._mouseLeave = false, this.onClick = (t) => {
      t.stopPropagation(), this.disabled || this.dispatchEvent(new Event("click"));
    }, this.showContextMenu = () => {
      let t = this._contextMenu;
      if (this.contextMenuTemplate && (t = Ut.create(() => {
        const e = Ut.create(this.contextMenuTemplate);
        return e instanceof Ee ? f`${e}` : f`
          <bim-context-menu>${e}</bim-context-menu>
        `;
      }), this.append(t), t.addEventListener("hidden", () => {
        t == null || t.remove();
      })), t) {
        const e = this.getAttribute("data-context-group");
        e && t.setAttribute("data-context-group", e), this.closeNestedContexts();
        const i = he.newRandomId();
        for (const n of t.children)
          n instanceof Pt && n.setAttribute("data-context-group", i);
        t.visible = true;
      }
    }, this.mouseLeave = true;
  }
  set loading(t) {
    if (this._loading = t, t)
      this._stateBeforeLoading = {
        disabled: this.disabled,
        icon: this.icon
      }, this.disabled = t, this.icon = "eos-icons:loading";
    else {
      const { disabled: e, icon: i } = this._stateBeforeLoading;
      this.disabled = e, this.icon = i;
    }
  }
  get loading() {
    return this._loading;
  }
  set mouseLeave(t) {
    this._mouseLeave = t, t && (this.tooltipVisible = false, clearTimeout(this.timeoutID));
  }
  get mouseLeave() {
    return this._mouseLeave;
  }
  computeTooltipPosition() {
    const { value: t } = this._parent, { value: e } = this._tooltip;
    t && e && Pi(t, e, {
      placement: "bottom",
      middleware: [$i(10), ki(), Ei(), Si({ padding: 5 })]
    }).then((i) => {
      const { x: n, y: r } = i;
      Object.assign(e.style, {
        left: `${n}px`,
        top: `${r}px`
      });
    });
  }
  onMouseEnter() {
    if (!(this.tooltipTitle || this.tooltipText))
      return;
    this.mouseLeave = false;
    const t = this.tooltipTime ?? 700;
    this.timeoutID = setTimeout(() => {
      this.mouseLeave || (this.computeTooltipPosition(), this.tooltipVisible = true);
    }, t);
  }
  closeNestedContexts() {
    const t = this.getAttribute("data-context-group");
    if (t)
      for (const e of Ee.dialog.children) {
        const i = e.getAttribute("data-context-group");
        if (e instanceof Ee && i === t) {
          e.visible = false, e.removeAttribute("data-context-group");
          for (const n of e.children)
            n instanceof Pt && (n.closeNestedContexts(), n.removeAttribute("data-context-group"));
        }
      }
  }
  click() {
    this.disabled || super.click();
  }
  get _contextMenu() {
    return this.querySelector("bim-context-menu");
  }
  connectedCallback() {
    super.connectedCallback(), this.addEventListener("click", this.showContextMenu);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.removeEventListener("click", this.showContextMenu);
  }
  render() {
    const t = f`
      <div ${J(this._tooltip)} class="tooltip">
        ${this.tooltipTitle ? f`<p style="text-wrap: nowrap;">
              <strong>${this.tooltipTitle}</strong>
            </p>` : null}
        ${this.tooltipText ? f`<p style="width: 9rem;">${this.tooltipText}</p>` : null}
      </div>
    `;
    let e = f`${this.label}`;
    if ((this._contextMenu || this.contextMenuTemplate) && this.label) {
      const i = f`<svg
        xmlns="http://www.w3.org/2000/svg"
        height="1.125rem"
        viewBox="0 0 24 24"
        width="1.125rem"
        style="fill: var(--bim-label--c)"
      >
        <path d="M0 0h24v24H0V0z" fill="none" />
        <path d="M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" />
      </svg>`;
      e = f`
        <div style="display: flex; align-items: center;">
          ${this.label}
          ${i}
        </div>
      `;
    }
    return f`
      <div ${J(this._parent)} class="parent" @click=${this.onClick}>
        ${this.label || this.icon ? f`
              <div
                class="button"
                @mouseenter=${this.onMouseEnter}
                @mouseleave=${() => this.mouseLeave = true}
              >
                <bim-label
                  .icon=${this.icon}
                  .vertical=${this.vertical}
                  .labelHidden=${this.labelHidden}
                  >${e}</bim-label
                >
              </div>
            ` : null}
        ${this.tooltipTitle || this.tooltipText ? t : null}
      </div>
      <slot></slot>
    `;
  }
}, Pt.styles = S`
    :host {
      --bim-label--c: var(--bim-ui_bg-contrast-100, white);
      position: relative;
      display: block;
      flex: 1;
      pointer-events: none;
      background-color: var(--bim-button--bgc, var(--bim-ui_bg-contrast-20));
      border-radius: var(--bim-ui_size-4xs);
      transition: all 0.15s;
    }

    :host(:not([disabled]))::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: inherit;
      background-color: var(--bim-ui_main-base);
      clip-path: circle(0 at center center);
      box-sizing: border-box;
      transition:
        clip-path 0.3s cubic-bezier(0.65, 0.05, 0.36, 1),
        transform 0.15s;
    }

    :host(:not([disabled]):hover) {
      cursor: pointer;
    }

    bim-label {
      pointer-events: none;
    }

    .parent {
      --bim-icon--c: var(--bim-label--c);
      position: relative;
      display: flex;
      height: 100%;
      user-select: none;
      row-gap: 0.125rem;
      min-height: var(--bim-ui_size-5xl);
      min-width: var(--bim-ui_size-5xl);
    }

    .button,
    .children {
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
    }

    .children {
      padding: 0 0.375rem;
      position: absolute;
      height: 100%;
      right: 0;
    }

    :host(:not([label-hidden])[icon][vertical]) .parent {
      min-height: 2.5rem;
    }

    .button {
      flex-grow: 1;
      transition: transform 0.15s;
    }

    :host(:not([label-hidden])[label]) .button {
      justify-content: var(--bim-button--jc, center);
    }

    :host(:hover)::before {
      clip-path: circle(120% at center center);
    }

    :host(:hover) {
      --bim-label--c: var(--bim-ui_main-contrast);
      z-index: 2;
    }

    :host([active]) {
      background-color: var(--bim-ui_main-base);
    }

    :host(:not([disabled]):active) {
      background: transparent;
    }

    :host(:not([disabled]):active) .button,
    :host(:not([disabled]):active)::before {
      transform: scale(0.98);
    }

    :host(:not([label]):not([icon])) .children {
      flex: 1;
    }

    :host([vertical]) .parent {
      justify-content: center;
    }

    :host(:not([label-hidden])[label]) .button {
      padding: 0 0.5rem;
    }

    :host([disabled]) {
      --bim-label--c: var(--bim-ui_bg-contrast-80) !important;
      background-color: gray !important;
    }

    ::slotted(bim-button) {
      --bim-icon--fz: var(--bim-ui_size-base);
      --bim-button--bdrs: var(--bim-ui_size-4xs);
      --bim-button--olw: 0;
      --bim-button--olc: transparent;
    }

    .tooltip {
      position: absolute;
      padding: 0.75rem;
      z-index: 99;
      display: flex;
      flex-flow: column;
      row-gap: 0.375rem;
      box-shadow: 0 0 10px 3px rgba(0 0 0 / 20%);
      outline: 1px solid var(--bim-ui_bg-contrast-40);
      font-size: var(--bim-ui_size-xs);
      border-radius: var(--bim-ui_size-4xs);
      background-color: var(--bim-ui_bg-contrast-20);
      color: var(--bim-ui_bg-contrast-100);
      animation: openTooltips 0.15s ease-out forwards;
      transition: visibility 0.2s;
    }

    .tooltip p {
      margin: 0;
      padding: 0;
    }

    :host(:not([tooltip-visible])) .tooltip {
      animation: closeTooltips 0.15s ease-in forwards;
      visibility: hidden;
      display: none;
    }

    @keyframes closeTooltips {
      0% {
        display: flex;
        padding: 0.75rem;
        transform: translateY(0);
        opacity: 1;
      }
      90% {
        padding: 0.75rem;
      }
      100% {
        display: none;
        padding: 0;
        transform: translateY(-10px);
        opacity: 0;
      }
    }

    @keyframes openTooltips {
      0% {
        display: flex;
        transform: translateY(-10px);
        opacity: 0;
      }
      100% {
        transform: translateY(0);
        opacity: 1;
      }
    }
  `, Pt);
G([
  d({ type: String, reflect: true })
], N.prototype, "label", 2);
G([
  d({ type: Boolean, attribute: "label-hidden", reflect: true })
], N.prototype, "labelHidden", 2);
G([
  d({ type: Boolean, reflect: true })
], N.prototype, "active", 2);
G([
  d({ type: Boolean, reflect: true, attribute: "disabled" })
], N.prototype, "disabled", 2);
G([
  d({ type: String, reflect: true })
], N.prototype, "icon", 2);
G([
  d({ type: Boolean, reflect: true })
], N.prototype, "vertical", 2);
G([
  d({ type: Number, attribute: "tooltip-time", reflect: true })
], N.prototype, "tooltipTime", 2);
G([
  d({ type: Boolean, attribute: "tooltip-visible", reflect: true })
], N.prototype, "tooltipVisible", 2);
G([
  d({ type: String, attribute: "tooltip-title", reflect: true })
], N.prototype, "tooltipTitle", 2);
G([
  d({ type: String, attribute: "tooltip-text", reflect: true })
], N.prototype, "tooltipText", 2);
G([
  d({ type: Boolean, reflect: true })
], N.prototype, "loading", 1);
var Ea = N;
var ka = Object.defineProperty;
var ve = (s, t, e, i) => {
  for (var n = void 0, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (n = o(t, e, n) || n);
  return n && ka(t, e, n), n;
};
var qi = class qi2 extends C {
  constructor() {
    super(...arguments), this.checked = false, this.inverted = false, this.onValueChange = new Event("change");
  }
  /**
   * A getter that returns the current checked state of the checkbox. This is useful for retrieving the checkbox's value in form submissions or JavaScript interactions as it provides a consistent `value` property as many other components.
   * @type {boolean}
   * @default false
   * @example <script>console.log(document.querySelector('bim-checkbox').value);<\/script>
   * @example
   * const checkbox = document.createElement('bim-checkbox');
   * document.body.appendChild(checkbox);
   * console.log(checkbox.value); // false initially
   */
  get value() {
    return this.checked;
  }
  onChange(t) {
    t.stopPropagation(), this.checked = t.target.checked, this.dispatchEvent(this.onValueChange);
  }
  render() {
    const t = f`
      <svg viewBox="0 0 21 21">
        <polyline points="5 10.75 8.5 14.25 16 6"></polyline>
      </svg>
    `;
    return f`
      <div class="parent">
        <label class="parent-label">
          ${this.label ? f`<bim-label .icon="${this.icon}">${this.label}</bim-label> ` : null}
          <div class="input-container">
            <input
              type="checkbox"
              aria-label=${this.label || this.name || "Checkbox Input"}
              @change="${this.onChange}"
              .checked="${this.checked}"
            />
            ${t}
          </div>
        </label>
      </div>
    `;
  }
};
qi.styles = S`
    :host {
      display: block;
    }

    .parent-label {
      --background: #fff;
      --border: #dfdfe6;
      --stroke: #fff;
      --border-hover: var(--bim-ui_main-base);
      --border-active: var(--bim-ui_main-base);
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      width: 100%;
      height: 1.75rem;
      column-gap: 0.25rem;
      position: relative;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    :host([inverted]) .parent-label {
      flex-direction: row-reverse;
      justify-content: start;
    }

    input,
    svg {
      width: 1rem;
      height: 1rem;
      display: block;
    }

    input {
      -webkit-appearance: none;
      -moz-appearance: none;
      position: relative;
      outline: none;
      background: var(--background);
      border: none;
      margin: 0;
      padding: 0;
      cursor: pointer;
      border-radius: 4px;
      transition: box-shadow 0.3s;
      box-shadow: inset 0 0 0 var(--s, 1px) var(--b, var(--border));
    }

    svg {
      pointer-events: none;
      fill: none;
      stroke-width: 2.2px;
      stroke-linecap: round;
      stroke-linejoin: round;
      stroke: var(--stroke, var(--border-active));
      transform: translateY(-100%) scale(0);
      position: absolute;
      width: 1rem;
      height: 1rem;
    }

    input:hover {
      --s: 2px;
      --b: var(--border-hover);
    }

    input:checked {
      --b: var(--border-active);
      --s: 11px;
    }

    input:checked + svg {
      -webkit-animation: bounce 0.4s linear forwards 0.2s;
      animation: bounce 0.4s linear forwards 0.2s;
    }

    @keyframes bounce {
      0% {
        transform: translateY(-100%) scale(0);
      }
      50% {
        transform: translateY(-100%) scale(1.2);
      }
      75% {
        transform: translateY(-100%) scale(0.9);
      }
      100% {
        transform: translateY(-100%) scale(1);
      }
    }
  `;
var bt = qi;
ve([
  d({ type: String, reflect: true })
], bt.prototype, "icon");
ve([
  d({ type: String, reflect: true })
], bt.prototype, "name");
ve([
  d({ type: String, reflect: true })
], bt.prototype, "label");
ve([
  d({ type: Boolean, reflect: true })
], bt.prototype, "checked");
ve([
  d({ type: Boolean, reflect: true })
], bt.prototype, "inverted");
var Pa = Object.defineProperty;
var Rt = (s, t, e, i) => {
  for (var n = void 0, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (n = o(t, e, n) || n);
  return n && Pa(t, e, n), n;
};
var Vi = class Vi2 extends C {
  constructor() {
    super(...arguments), this.vertical = false, this.color = "#bcf124", this.disabled = false, this._colorInput = Vt(), this._textInput = Vt(), this.onValueChange = new Event("input"), this.onOpacityInput = (t) => {
      const e = t.target;
      this.opacity = e.value, this.dispatchEvent(this.onValueChange);
    };
  }
  /**
   * Represents both the color and opacity values combined into a single object. This is an instance property, not an HTMLElement attribute.
   * @type {Object}
   * @example
   * const colorInput = document.createElement('bim-color-input');
   * colorInput.value = { color: '#ff0000', opacity: 0.5 };
   */
  set value(t) {
    const { color: e, opacity: i } = t;
    this.color = e, i && (this.opacity = i);
  }
  get value() {
    const t = {
      color: this.color
    };
    return this.opacity && (t.opacity = this.opacity), t;
  }
  onColorInput(t) {
    t.stopPropagation();
    const { value: e } = this._colorInput;
    e && (this.color = e.value, this.dispatchEvent(this.onValueChange));
  }
  onTextInput(t) {
    t.stopPropagation();
    const { value: e } = this._textInput;
    if (!e)
      return;
    const { value: i } = e;
    let n = i.replace(/[^a-fA-F0-9]/g, "");
    n.startsWith("#") || (n = `#${n}`), e.value = n.slice(0, 7), e.value.length === 7 && (this.color = e.value, this.dispatchEvent(this.onValueChange));
  }
  /**
   * Focuses on the color input by programmatically triggering a click event on the underlying color input element.
   * If the color input element is not available, the function does nothing.
   */
  focus() {
    const { value: t } = this._colorInput;
    t && t.click();
  }
  render() {
    return f`
      <div class="parent">
        <bim-input
          .label=${this.label}
          .icon=${this.icon}
          .vertical="${this.vertical}"
        >
          <div class="color-container">
            <div
              style="display: flex; align-items: center; gap: .375rem; height: 100%; flex: 1; padding: 0 0.5rem;"
            >
              <input
                ${J(this._colorInput)}
                @input="${this.onColorInput}"
                type="color"
                aria-label=${this.label || this.name || "Color Input"}
                value="${this.color}"
                ?disabled=${this.disabled}
              />
              <div
                @click=${this.focus}
                class="sample"
                style="background-color: ${this.color}"
              ></div>
              <input
                ${J(this._textInput)}
                @input="${this.onTextInput}"
                value="${this.color}"
                type="text"
                aria-label=${this.label || this.name || "Text Color Input"}
                ?disabled=${this.disabled}
              />
            </div>
            ${this.opacity !== void 0 ? f`<bim-number-input
                  @change=${this.onOpacityInput}
                  slider
                  suffix="%"
                  min="0"
                  value=${this.opacity}
                  max="100"
                ></bim-number-input>` : null}
          </div>
        </bim-input>
      </div>
    `;
  }
};
Vi.styles = S`
    :host {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
      flex: 1;
      display: block;
    }

    :host(:focus) {
      --bim-input--olw: var(--bim-number-input--olw, 2px);
      --bim-input--olc: var(--bim-ui_accent-base);
    }

    .parent {
      display: flex;
      gap: 0.375rem;
    }

    .color-container {
      position: relative;
      outline: none;
      display: flex;
      height: 100%;
      gap: 0.5rem;
      justify-content: flex-start;
      align-items: center;
      flex: 1;
      border-radius: var(--bim-color-input--bdrs, var(--bim-ui_size-4xs));
    }

    .color-container input[type="color"] {
      position: absolute;
      bottom: -0.25rem;
      visibility: hidden;
      width: 0;
      height: 0;
    }

    .color-container .sample {
      width: 1rem;
      height: 1rem;
      border-radius: 0.125rem;
      background-color: #fff;
    }

    .color-container input[type="text"] {
      height: 100%;
      flex: 1;
      width: 3.25rem;
      text-transform: uppercase;
      font-size: 0.75rem;
      background-color: transparent;
      padding: 0%;
      outline: none;
      border: none;
      color: var(--bim-color-input--c, var(--bim-ui_bg-contrast-100));
    }

    :host([disabled]) .color-container input[type="text"] {
      color: var(--bim-ui_bg-contrast-60);
    }

    bim-number-input {
      flex-grow: 0;
    }
  `;
var tt = Vi;
Rt([
  d({ type: String, reflect: true })
], tt.prototype, "name");
Rt([
  d({ type: String, reflect: true })
], tt.prototype, "label");
Rt([
  d({ type: String, reflect: true })
], tt.prototype, "icon");
Rt([
  d({ type: Boolean, reflect: true })
], tt.prototype, "vertical");
Rt([
  d({ type: Number, reflect: true })
], tt.prototype, "opacity");
Rt([
  d({ type: String, reflect: true })
], tt.prototype, "color");
Rt([
  d({ type: Boolean, reflect: true })
], tt.prototype, "disabled");
var Ta = Object.defineProperty;
var Oa = Object.getOwnPropertyDescriptor;
var $t = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? Oa(t, e) : t, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (n = (i ? o(t, e, n) : o(n)) || n);
  return i && n && Ta(t, e, n), n;
};
var Ui = class Ui2 extends C {
  constructor() {
    super(...arguments), this.checked = false, this.checkbox = false, this.noMark = false, this.vertical = false;
  }
  get value() {
    return this._value !== void 0 ? this._value : this.label ? Ge(this.label) : this.label;
  }
  set value(t) {
    this._value = t;
  }
  render() {
    return f`
      <div class="parent" .title=${this.label ?? ""}>
        ${this.img || this.icon || this.label ? f` <div style="display: flex; column-gap: 0.375rem">
              ${this.checkbox && !this.noMark ? f`<bim-checkbox
                    style="pointer-events: none"
                    .checked=${this.checked}
                  ></bim-checkbox>` : null}
              <bim-label
                .vertical=${this.vertical}
                .icon=${this.icon}
                .img=${this.img}
                >${this.label}</bim-label
              >
            </div>` : null}
        ${!this.checkbox && !this.noMark && this.checked ? f`<svg
              xmlns="http://www.w3.org/2000/svg"
              height="1.125rem"
              viewBox="0 0 24 24"
              width="1.125rem"
              fill="#FFFFFF"
            >
              <path d="M0 0h24v24H0z" fill="none" />
              <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" />
            </svg>` : null}
        <slot></slot>
      </div>
    `;
  }
};
Ui.styles = S`
    :host {
      --bim-label--c: var(--bim-ui_bg-contrast-100);
      display: block;
      box-sizing: border-box;
      flex: 1;
      padding: 0rem 0.5rem;
      border-radius: var(--bim-ui_size-4xs);
      transition: all 0.15s;
    }

    :host(:hover) {
      cursor: pointer;
    }

    :host([checked]) {
      --bim-label--c: color-mix(in lab, var(--bim-ui_main-base), white 30%);
    }

    :host([checked]) svg {
      fill: color-mix(in lab, var(--bim-ui_main-base), white 30%);
    }

    .parent {
      box-sizing: border-box;
      display: flex;
      justify-content: var(--bim-option--jc, space-between);
      column-gap: 0.5rem;
      align-items: center;
      min-height: 1.75rem;
      height: 100%;
    }

    input {
      height: 1rem;
      width: 1rem;
      cursor: pointer;
      border: none;
      outline: none;
      accent-color: var(--bim-checkbox--c, var(--bim-ui_main-base));
    }

    input:focus {
      outline: var(--bim-checkbox--olw, 2px) solid
        var(--bim-checkbox--olc, var(--bim-ui_accent-base));
    }

    bim-label {
      pointer-events: none;
      z-index: 1;
    }
  `;
var T = Ui;
$t([
  d({ type: String, reflect: true })
], T.prototype, "img", 2);
$t([
  d({ type: String, reflect: true })
], T.prototype, "label", 2);
$t([
  d({ type: String, reflect: true })
], T.prototype, "icon", 2);
$t([
  d({ type: Boolean, reflect: true })
], T.prototype, "checked", 2);
$t([
  d({ type: Boolean, reflect: true })
], T.prototype, "checkbox", 2);
$t([
  d({ type: Boolean, attribute: "no-mark", reflect: true })
], T.prototype, "noMark", 2);
$t([
  d({
    converter: {
      fromAttribute(s) {
        return s && Ge(s);
      }
    }
  })
], T.prototype, "value", 1);
$t([
  d({ type: Boolean, reflect: true })
], T.prototype, "vertical", 2);
var Ia = Object.defineProperty;
var La = Object.getOwnPropertyDescriptor;
var et = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? La(t, e) : t, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (n = (i ? o(t, e, n) : o(n)) || n);
  return i && n && Ia(t, e, n), n;
};
var Wi = class Wi2 extends Ut {
  constructor() {
    super(), this.multiple = false, this.required = false, this.vertical = false, this._visible = false, this._value = /* @__PURE__ */ new Set(), this.onValueChange = new Event("change"), this._contextMenu = Vt(), this.onOptionClick = (t) => {
      const e = t.target, i = this._value.has(e);
      if (!this.multiple && !this.required && !i)
        this._value = /* @__PURE__ */ new Set([e]);
      else if (!this.multiple && !this.required && i)
        this._value = /* @__PURE__ */ new Set([]);
      else if (!this.multiple && this.required && !i)
        this._value = /* @__PURE__ */ new Set([e]);
      else if (this.multiple && !this.required && !i)
        this._value = /* @__PURE__ */ new Set([...this._value, e]);
      else if (this.multiple && !this.required && i) {
        const n = [...this._value].filter((r) => r !== e);
        this._value = new Set(n);
      } else if (this.multiple && this.required && !i)
        this._value = /* @__PURE__ */ new Set([...this._value, e]);
      else if (this.multiple && this.required && i) {
        const n = [...this._value].filter((o) => o !== e), r = new Set(n);
        r.size !== 0 && (this._value = r);
      }
      this.updateOptionsState(), this.dispatchEvent(this.onValueChange);
    }, this.onSearch = ({ target: t }) => {
      const e = t.value.toLowerCase();
      for (const i of this._options) {
        if (!(i instanceof T))
          continue;
        (i.label || i.value || "").toLowerCase().includes(e) ? i.style.display = "" : i.style.display = "none";
      }
    }, this.useObserver = true;
  }
  set visible(t) {
    var e;
    if (t) {
      const { value: i } = this._contextMenu;
      if (!i)
        return;
      for (const n of this.elements)
        i.append(n);
      this._visible = true;
    } else {
      for (const n of this.elements)
        this.append(n);
      this._visible = false, this.resetVisibleElements();
      for (const n of this._options)
        n instanceof T && (n.style.display = "");
      const i = (e = this._contextMenu.value) == null ? void 0 : e.querySelector("bim-text-input");
      i && (i.value = "");
    }
  }
  get visible() {
    return this._visible;
  }
  /**
   * The selected values in the dropdown.
   * @type {any[]}
   * @example
   * const dropdown = document.createElement('bim-dropdown');
   * dropdown.value = ['option1', 'option2'];
   */
  set value(t) {
    if (this.required && Object.keys(t).length === 0)
      return;
    const e = /* @__PURE__ */ new Set();
    for (const i of t) {
      const n = this.findOption(i);
      if (n && (e.add(n), !this.multiple && Object.keys(t).length === 1))
        break;
    }
    this._value = e, this.updateOptionsState(), this.dispatchEvent(this.onValueChange);
  }
  get value() {
    return [...this._value].filter(
      (e) => e instanceof T && e.checked
    ).map((e) => e.value);
  }
  get _options() {
    const t = /* @__PURE__ */ new Set([...this.elements]);
    for (const e of this.children)
      e instanceof T && t.add(e);
    return [...t];
  }
  onSlotChange(t) {
    const e = t.target.assignedElements();
    this.observe(e);
    const i = /* @__PURE__ */ new Set();
    for (const n of this.elements) {
      if (!(n instanceof T)) {
        n.remove();
        continue;
      }
      n.checked && i.add(n), n.removeEventListener("click", this.onOptionClick), n.addEventListener("click", this.onOptionClick);
    }
    this._value = i;
  }
  updateOptionsState() {
    for (const t of this._options)
      t instanceof T && (t.checked = this._value.has(t));
  }
  findOption(t) {
    return this._options.find((i) => i instanceof T ? i.label === t || i.value === t : false);
  }
  render() {
    let t, e, i;
    if (this._value.size === 0)
      t = this.placeholder ?? "Select an option...";
    else if (this._value.size === 1) {
      const n = [...this._value][0];
      t = (n == null ? void 0 : n.label) || (n == null ? void 0 : n.value), e = n == null ? void 0 : n.img, i = n == null ? void 0 : n.icon;
    } else
      t = `Multiple (${this._value.size})`;
    return f`
      <bim-input
        title=${this.label ?? ""}
        .label=${this.label}
        .icon=${this.icon}
        .vertical=${this.vertical}
      >
        <div class="input" @click=${() => this.visible = !this.visible}>
          <bim-label
            .img=${e}
            .icon=${i}
            style="overflow: hidden;"
            >${t}</bim-label
          >
          <svg
            style="flex-shrink: 0; fill: var(--bim-dropdown--c, var(--bim-ui_bg-contrast-100))"
            xmlns="http://www.w3.org/2000/svg"
            height="1.125rem"
            viewBox="0 0 24 24"
            width="1.125rem"
            fill="#9ca3af"
          >
            <path d="M0 0h24v24H0V0z" fill="none" />
            <path d="M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" />
          </svg>
          <bim-context-menu
            ${J(this._contextMenu)}
            .visible=${this.visible}
            @hidden=${() => {
      this.visible && (this.visible = false);
    }}
          >
            ${this.searchBox ? f`<bim-text-input @input=${this.onSearch} placeholder="Search..." debounce=200 style="--bim-input--bgc: var(--bim-ui_bg-contrast-30)"></bim-text-input>` : E}
            <slot @slotchange=${this.onSlotChange}></slot>
          </bim-context-menu>
        </div>
      </bim-input>
    `;
  }
};
Wi.styles = [
  xt.scrollbar,
  S`
      :host {
        --bim-input--bgc: var(
          --bim-dropdown--bgc,
          var(--bim-ui_bg-contrast-20)
        );
        --bim-input--olw: 2px;
        --bim-input--olc: transparent;
        --bim-input--bdrs: var(--bim-ui_size-4xs);
        flex: 1;
        display: block;
      }

      :host([visible]) {
        --bim-input--olc: var(--bim-ui_accent-base);
      }

      .input {
        --bim-label--fz: var(--bim-drodown--fz, var(--bim-ui_size-xs));
        --bim-label--c: var(--bim-dropdown--c, var(--bim-ui_bg-contrast-100));
        height: 100%;
        display: flex;
        flex: 1;
        overflow: hidden;
        column-gap: 0.25rem;
        outline: none;
        cursor: pointer;
        align-items: center;
        justify-content: space-between;
        padding: 0 0.5rem;
      }

      bim-label {
        pointer-events: none;
      }
    `
];
var H = Wi;
et([
  d({ type: String, reflect: true })
], H.prototype, "name", 2);
et([
  d({ type: String, reflect: true })
], H.prototype, "icon", 2);
et([
  d({ type: String, reflect: true })
], H.prototype, "label", 2);
et([
  d({ type: Boolean, reflect: true })
], H.prototype, "multiple", 2);
et([
  d({ type: Boolean, reflect: true })
], H.prototype, "required", 2);
et([
  d({ type: Boolean, reflect: true })
], H.prototype, "vertical", 2);
et([
  d({ type: String, reflect: true })
], H.prototype, "placeholder", 2);
et([
  d({ type: Boolean, reflect: true, attribute: "search-box" })
], H.prototype, "searchBox", 2);
et([
  d({ type: Boolean, reflect: true })
], H.prototype, "visible", 1);
et([
  Lt()
], H.prototype, "_value", 2);
var Ra = Object.defineProperty;
var Ys = (s, t, e, i) => {
  for (var n = void 0, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (n = o(t, e, n) || n);
  return n && Ra(t, e, n), n;
};
var Yi = class Yi2 extends C {
  constructor() {
    super(...arguments), this.floating = false, this._layouts = {}, this._elements = {}, this._templateIds = /* @__PURE__ */ new Map(), this._updateFunctions = {}, this._slotNames = {
      notAllowed: "not-allowed",
      notFound: "not-found",
      emptyLayout: "empty-layout"
    }, this.updateComponent = {}, this.emitLayoutChange = () => {
      this.dispatchEvent(new Event("layoutchange"));
    };
  }
  /**
   * Represents a collection of predefined grid layouts for the Grid component.
   * Each layout is defined by a unique name, a grid template string, and a map of area names to HTMLElement instances or
   * Statefull/Stateless component definitions.
   * The grid template string defines the structure of the grid, and the area names correspond to the grid-area property of the HTMLElement instances.
   * The HTMLElement instances are used to populate the grid with content.
   * @remarks Once defined, the layout is meant to be immutable.
   */
  set layouts(t) {
    this._layouts = t, this._templateIds.clear();
  }
  get layouts() {
    return this._layouts;
  }
  set elements(t) {
    this._elements = t, this.setUpdateFunctions();
  }
  get elements() {
    return this._elements;
  }
  getLayoutAreas(t) {
    const { template: e } = t, r = e.split(`
`).map((a) => a.trim()).map((a) => a.split('"')[1]).filter((a) => a !== void 0).flatMap((a) => a.split(/\s+/));
    return [...new Set(r)].filter((a) => a !== "");
  }
  setUpdateFunctions() {
    const t = {};
    for (const [e, i] of Object.entries(this.elements))
      "template" in i && (t[e] = (n) => {
        var r, o;
        (o = (r = this._updateFunctions)[e]) == null || o.call(r, n);
      });
    this.updateComponent = t;
  }
  // connectedCallback() {
  //   super.connectedCallback()
  //   this.setUpdateFunctions()
  // }
  disconnectedCallback() {
    super.disconnectedCallback(), this._templateIds.clear(), this._updateFunctions = {}, this.updateComponent = {};
  }
  getTemplateId(t) {
    let e = this._templateIds.get(t);
    return e || (e = he.newRandomId(), this._templateIds.set(t, e)), e;
  }
  cleanUpdateFunctions() {
    if (!this.layout) {
      this._updateFunctions = {};
      return;
    }
    const t = this.layouts[this.layout], e = this.getLayoutAreas(t);
    for (const i in this.elements)
      e.includes(i) || delete this._updateFunctions[i];
  }
  clean() {
    this.style.gridTemplate = "";
    for (const t of [...this.children])
      Object.values(this._slotNames).some(
        (e) => t.getAttribute("slot") === e
      ) || t.remove();
    this.cleanUpdateFunctions();
  }
  emitElementCreation(t) {
    this.dispatchEvent(new CustomEvent("elementcreated", {
      detail: t
    }));
  }
  render() {
    if (this.layout) {
      const t = this.layouts[this.layout];
      if (t) {
        if (!(t.guard ?? (() => true))())
          return this.clean(), f`<slot name=${this._slotNames.notAllowed}></slot>`;
        const r = this.getLayoutAreas(t).map((o) => {
          var h;
          const a = ((h = t.elements) == null ? void 0 : h[o]) || this.elements[o];
          if (!a)
            return null;
          if (a instanceof HTMLElement)
            return a.style.gridArea = o, a;
          if ("template" in a) {
            const { template: p, initialState: m } = a, g = this.getTemplateId(p), v = this.querySelector(
              `[data-grid-template-id="${g}"]`
            );
            if (v)
              return v;
            const [b, w] = Ut.create(p, m);
            return this.emitElementCreation({ name: o, element: b }), b.setAttribute("data-grid-template-id", g), b.style.gridArea = o, this._updateFunctions[o] = w, b;
          }
          const l = this.getTemplateId(a), c = this.querySelector(
            `[data-grid-template-id="${l}"]`
          );
          if (c)
            return c;
          const u = Ut.create(a);
          return this.emitElementCreation({ name: o, element: u }), u.setAttribute(
            "data-grid-template-id",
            this.getTemplateId(a)
          ), u.style.gridArea = o, u;
        }).filter((o) => o !== null);
        this.clean(), this.style.gridTemplate = t.template, this.append(...r), this.emitLayoutChange();
      } else
        return this.clean(), f`<slot name=${this._slotNames.notFound}></slot>`;
    } else
      return this.clean(), this.emitLayoutChange(), f`<slot name=${this._slotNames.emptyLayout}></slot>`;
    return f`${f`<slot></slot>`}`;
  }
};
Yi.styles = S`
    :host {
      display: grid;
      height: 100%;
      width: 100%;
      overflow: hidden;
      box-sizing: border-box;
    }

    /* :host(:not([layout])) {
      display: none;
    } */

    :host([floating]) {
      --bim-panel--bdrs: var(--bim-ui_size-4xs);
      background-color: transparent;
      padding: 1rem;
      gap: 1rem;
      position: absolute;
      pointer-events: none;
      top: 0px;
      left: 0px;
    }

    :host(:not([floating])) {
      --bim-panel--bdrs: 0;
      background-color: var(--bim-ui_bg-contrast-20);
      gap: 1px;
    }
  `;
var de = Yi;
Ys([
  d({ type: Boolean, reflect: true })
], de.prototype, "floating");
Ys([
  d({ type: String, reflect: true })
], de.prototype, "layout");
var He = class He2 extends C {
  render() {
    return f`
      <iconify-icon .icon=${this.icon} height="none"></iconify-icon>
    `;
  }
};
He.styles = S`
    :host {
      height: var(--bim-icon--fz, var(--bim-ui_size-sm));
      width: var(--bim-icon--fz, var(--bim-ui_size-sm));
    }

    iconify-icon {
      height: var(--bim-icon--fz, var(--bim-ui_size-sm));
      width: var(--bim-icon--fz, var(--bim-ui_size-sm));
      color: var(--bim-icon--c);
      transition: all 0.15s;
      display: flex;
    }
  `, He.properties = {
  icon: { type: String }
};
var _i = He;
var za = Object.defineProperty;
var Qe = (s, t, e, i) => {
  for (var n = void 0, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (n = o(t, e, n) || n);
  return n && za(t, e, n), n;
};
var Gi = class Gi2 extends C {
  constructor() {
    super(...arguments), this.vertical = false, this.onValueChange = new Event("change");
  }
  get value() {
    const t = {};
    for (const e of this.children) {
      const i = e;
      "value" in i ? t[i.name || i.label] = i.value : "checked" in i && (t[i.name || i.label] = i.checked);
    }
    return t;
  }
  set value(t) {
    const e = [...this.children];
    for (const i in t) {
      const n = e.find((a) => {
        const l = a;
        return l.name === i || l.label === i;
      });
      if (!n)
        continue;
      const r = n, o = t[i];
      typeof o == "boolean" ? r.checked = o : r.value = o;
    }
  }
  render() {
    return f`
      <div class="parent">
        ${this.label || this.icon ? f`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
        <div class="input">
          <slot></slot>
        </div>
      </div>
    `;
  }
};
Gi.styles = S`
    :host {
      flex: 1;
      display: block;
    }

    .parent {
      display: flex;
      flex-wrap: wrap;
      column-gap: 1rem;
      row-gap: 0.375rem;
      user-select: none;
      flex: 1;
    }

    :host(:not([vertical])) .parent {
      justify-content: space-between;
    }

    :host([vertical]) .parent {
      flex-direction: column;
    }

    .input {
      position: relative;
      overflow: hidden;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      min-height: 1.75rem;
      min-width: 3rem;
      gap: var(--bim-input--g, var(--bim-ui_size-4xs));
      padding: var(--bim-input--p, 0);
      background-color: var(--bim-input--bgc, transparent);
      border: var(--bim-input--olw, 2px) solid
        var(--bim-input--olc, transparent);
      border-radius: var(--bim-input--bdrs, var(--bim-ui_size-4xs));
      transition: all 0.15s;
    }

    :host(:not([vertical])) .input {
      flex: 1;
      justify-content: flex-end;
    }

    :host(:not([vertical])[label]) .input {
      max-width: fit-content;
    }
  `;
var It = Gi;
Qe([
  d({ type: String, reflect: true })
], It.prototype, "name");
Qe([
  d({ type: String, reflect: true })
], It.prototype, "label");
Qe([
  d({ type: String, reflect: true })
], It.prototype, "icon");
Qe([
  d({ type: Boolean, reflect: true })
], It.prototype, "vertical");
function Dt(s, t, e) {
  return s ? t(s) : e == null ? void 0 : e(s);
}
var wi = (s) => s ?? E;
var Ba = Object.defineProperty;
var ye = (s, t, e, i) => {
  for (var n = void 0, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (n = o(t, e, n) || n);
  return n && Ba(t, e, n), n;
};
var Qi = class Qi2 extends C {
  constructor() {
    super(...arguments), this.labelHidden = false, this.iconHidden = false, this.vertical = false, this._imgTemplate = () => f`<img src=${wi(this.img)} .alt=${this.textContent || ""} />`, this._iconTemplate = () => f`<bim-icon .icon=${this.icon}></bim-icon>`;
  }
  get value() {
    return this.textContent ? Ge(this.textContent) : this.textContent;
  }
  render() {
    return f`
      <div class="parent" title=${this.textContent}>
        ${Dt(this.img, this._imgTemplate, () => E)}
        ${Dt(!this.iconHidden && this.icon, this._iconTemplate, () => E)}
        <p><slot></slot></p>
      </div>
    `;
  }
};
Qi.styles = S`
    :host {
      --bim-icon--c: var(--bim-label--ic);
      overflow: auto;
      color: var(--bim-label--c, var(--bim-ui_bg-contrast-60));
      font-size: var(--bim-label--fz, var(--bim-ui_size-xs));
      display: block;
      white-space: nowrap;
      transition: all 0.15s;
      user-select: none;
    }

    :host([icon]) {
      line-height: 1.1rem;
    }

    .parent {
      display: flex;
      align-items: center;
      column-gap: 0.25rem;
      row-gap: 0.125rem;
      height: 100%;
    }

    :host([vertical]) .parent {
      flex-direction: column;
    }

    .parent p {
      margin: 0;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    :host([label-hidden]) .parent p,
    :host(:empty) .parent p {
      display: none;
    }

    img {
      height: 100%;
      aspect-ratio: 1;
      border-radius: 100%;
      margin-right: 0.125rem;
    }

    :host(:not([vertical])) img {
      max-height: var(
        --bim-label_icon--sz,
        calc(var(--bim-label--fz, var(--bim-ui_size-xs)) * 1.8)
      );
    }

    :host([vertical]) img {
      max-height: var(
        --bim-label_icon--sz,
        calc(var(--bim-label--fz, var(--bim-ui_size-xs)) * 4)
      );
    }
  `;
var gt = Qi;
ye([
  d({ type: String, reflect: true })
], gt.prototype, "img");
ye([
  d({ type: Boolean, attribute: "label-hidden", reflect: true })
], gt.prototype, "labelHidden");
ye([
  d({ type: String, reflect: true })
], gt.prototype, "icon");
ye([
  d({ type: Boolean, attribute: "icon-hidden", reflect: true })
], gt.prototype, "iconHidden");
ye([
  d({ type: Boolean, reflect: true })
], gt.prototype, "vertical");
var Ma = Object.defineProperty;
var ja = Object.getOwnPropertyDescriptor;
var q = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? ja(t, e) : t, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (n = (i ? o(t, e, n) : o(n)) || n);
  return i && n && Ma(t, e, n), n;
};
var Ki = class Ki2 extends C {
  constructor() {
    super(...arguments), this._value = 0, this.vertical = false, this.slider = false, this._input = Vt(), this.onValueChange = new Event("change");
  }
  set value(t) {
    this.setValue(t.toString());
  }
  get value() {
    return this._value;
  }
  onChange(t) {
    t.stopPropagation();
    const { value: e } = this._input;
    e && this.setValue(e.value);
  }
  setValue(t) {
    const { value: e } = this._input;
    let i = t;
    if (i = i.replace(/[^0-9.-]/g, ""), i = i.replace(/(\..*)\./g, "$1"), i.endsWith(".") || (i.lastIndexOf("-") > 0 && (i = i[0] + i.substring(1).replace(/-/g, "")), i === "-" || i === "-0"))
      return;
    let n = Number(i);
    Number.isNaN(n) || (n = this.min !== void 0 ? Math.max(n, this.min) : n, n = this.max !== void 0 ? Math.min(n, this.max) : n, this.value !== n && (this._value = n, e && (e.value = this.value.toString()), this.requestUpdate(), this.dispatchEvent(this.onValueChange)));
  }
  onBlur() {
    const { value: t } = this._input;
    t && Number.isNaN(Number(t.value)) && (t.value = this.value.toString());
  }
  onSliderMouseDown(t) {
    document.body.style.cursor = "w-resize";
    const { clientX: e } = t, i = this.value;
    let n = false;
    const r = (l) => {
      var v;
      n = true;
      const { clientX: c } = l, u = this.step ?? 1, h = ((v = u.toString().split(".")[1]) == null ? void 0 : v.length) || 0, p = 1 / (this.sensitivity ?? 1), m = (c - e) / p;
      if (Math.floor(Math.abs(m)) !== Math.abs(m))
        return;
      const g = i + m * u;
      this.setValue(g.toFixed(h));
    }, o = () => {
      this.slider = true, this.removeEventListener("blur", o);
    }, a = () => {
      document.removeEventListener("mousemove", r), document.body.style.cursor = "default", n ? n = false : (this.addEventListener("blur", o), this.slider = false, requestAnimationFrame(() => this.focus())), document.removeEventListener("mouseup", a);
    };
    document.addEventListener("mousemove", r), document.addEventListener("mouseup", a);
  }
  onFocus(t) {
    t.stopPropagation();
    const e = (i) => {
      i.key === "Escape" && (this.blur(), window.removeEventListener("keydown", e));
    };
    window.addEventListener("keydown", e);
  }
  connectedCallback() {
    super.connectedCallback(), this.min && this.min > this.value && (this._value = this.min), this.max && this.max < this.value && (this._value = this.max);
  }
  /**
   * Sets focus to the input element of the number input component.
   * This method is useful for programmatically focusing the input element, for example,
   * in response to a user action or to emphasize the input in the UI.
   *
   * If the input element reference is not available (not yet rendered or disconnected),
   * this method will do nothing.
   */
  focus() {
    const { value: t } = this._input;
    t && t.focus();
  }
  render() {
    const t = f`
      ${this.pref || this.icon ? f`<bim-label
            style="pointer-events: auto"
            @mousedown=${this.onSliderMouseDown}
            .icon=${this.icon}
            >${this.pref}</bim-label
          >` : null}
      <input
        ${J(this._input)}
        type="text"
        aria-label=${this.label || this.name || "Number Input"}
        size="1"
        @input=${(a) => a.stopPropagation()}
        @change=${this.onChange}
        @blur=${this.onBlur}
        @focus=${this.onFocus}
        .value=${this.value.toString()}
      />
      ${this.suffix ? f`<bim-label
            style="pointer-events: auto"
            @mousedown=${this.onSliderMouseDown}
            >${this.suffix}</bim-label
          >` : null}
    `, e = this.min ?? -1 / 0, i = this.max ?? 1 / 0, n = 100 * (this.value - e) / (i - e), r = f`
      <style>
        .slider-indicator {
          width: ${`${n}%`};
        }
      </style>
      <div class="slider" @mousedown=${this.onSliderMouseDown}>
        <div class="slider-indicator"></div>
        ${this.pref || this.icon ? f`<bim-label
              style="z-index: 1; margin-right: 0.125rem"
              .icon=${this.icon}
              >${`${this.pref}: `}</bim-label
            >` : null}
        <bim-label style="z-index: 1;">${this.value}</bim-label>
        ${this.suffix ? f`<bim-label style="z-index: 1;">${this.suffix}</bim-label>` : null}
      </div>
    `, o = `${this.label || this.name || this.pref ? `${this.label || this.name || this.pref}: ` : ""}${this.value}${this.suffix ?? ""}`;
    return f`
      <bim-input
        title=${o}
        .label=${this.label}
        .icon=${this.icon}
        .vertical=${this.vertical}
      >
        ${this.slider ? r : t}
      </bim-input>
    `;
  }
};
Ki.styles = S`
    :host {
      --bim-input--bgc: var(
        --bim-number-input--bgc,
        var(--bim-ui_bg-contrast-20)
      );
      --bim-input--olw: var(--bim-number-input--olw, 2px);
      --bim-input--olc: var(--bim-number-input--olc, transparent);
      --bim-input--bdrs: var(--bim-number-input--bdrs, var(--bim-ui_size-4xs));
      --bim-input--p: 0 0.375rem;
      flex: 1;
      display: block;
    }

    :host(:focus) {
      --bim-input--olw: var(--bim-number-input--olw, 2px);
      --bim-input--olc: var(
        --bim-number-inputfocus--c,
        var(--bim-ui_accent-base)
      );
    }

    :host(:not([slider])) bim-label {
      --bim-label--c: var(
        --bim-number-input_affixes--c,
        var(--bim-ui_bg-contrast-60)
      );
      --bim-label--fz: var(
        --bim-number-input_affixes--fz,
        var(--bim-ui_size-xs)
      );
    }

    p {
      margin: 0;
      padding: 0;
    }

    input {
      background-color: transparent;
      outline: none;
      border: none;
      padding: 0;
      flex-grow: 1;
      text-align: right;
      font-family: inherit;
      font-feature-settings: inherit;
      font-variation-settings: inherit;
      font-size: var(--bim-number-input--fz, var(--bim-ui_size-xs));
      color: var(--bim-number-input--c, var(--bim-ui_bg-contrast-100));
    }

    :host([suffix]:not([pref])) input {
      text-align: left;
    }

    :host([slider]) {
      --bim-input--p: 0;
    }

    :host([slider]) .slider {
      --bim-label--c: var(--bim-ui_bg-contrast-100);
    }

    .slider {
      position: relative;
      display: flex;
      justify-content: center;
      width: 100%;
      height: 100%;
      padding: 0 0.5rem;
    }

    .slider-indicator {
      height: 100%;
      background-color: var(--bim-ui_main-base);
      position: absolute;
      top: 0;
      left: 0;
      border-radius: var(--bim-input--bdrs, var(--bim-ui_size-4xs));
    }

    bim-input {
      display: flex;
    }

    bim-label {
      pointer-events: none;
    }
  `;
var z = Ki;
q([
  d({ type: String, reflect: true })
], z.prototype, "name", 2);
q([
  d({ type: String, reflect: true })
], z.prototype, "icon", 2);
q([
  d({ type: String, reflect: true })
], z.prototype, "label", 2);
q([
  d({ type: String, reflect: true })
], z.prototype, "pref", 2);
q([
  d({ type: Number, reflect: true })
], z.prototype, "min", 2);
q([
  d({ type: Number, reflect: true })
], z.prototype, "value", 1);
q([
  d({ type: Number, reflect: true })
], z.prototype, "step", 2);
q([
  d({ type: Number, reflect: true })
], z.prototype, "sensitivity", 2);
q([
  d({ type: Number, reflect: true })
], z.prototype, "max", 2);
q([
  d({ type: String, reflect: true })
], z.prototype, "suffix", 2);
q([
  d({ type: Boolean, reflect: true })
], z.prototype, "vertical", 2);
q([
  d({ type: Boolean, reflect: true })
], z.prototype, "slider", 2);
var Da = Object.defineProperty;
var Ha = Object.getOwnPropertyDescriptor;
var _e = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? Ha(t, e) : t, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (n = (i ? o(t, e, n) : o(n)) || n);
  return i && n && Da(t, e, n), n;
};
var Xi = class Xi2 extends C {
  constructor() {
    super(...arguments), this.onValueChange = new Event("change"), this._hidden = false, this.headerHidden = false, this.valueTransform = {}, this.activationButton = document.createElement("bim-button");
  }
  set hidden(t) {
    this._hidden = t, this.activationButton.active = !t, this.dispatchEvent(new Event("hiddenchange"));
  }
  get hidden() {
    return this._hidden;
  }
  /**
   * The `value` getter computes and returns the current state of the panel's form elements as an object. This property is dynamic and reflects the current input values within the panel. When accessed, it traverses the panel's child elements, collecting values from those that have a `name` or `label` attribute, and constructs an object where each key corresponds to the `name` or `label` of the element, and the value is the element's value. This property is particularly useful for forms or interactive panels where the user's input needs to be retrieved programmatically. The value returned is a snapshot of the panel's state at the time of access, and it does not maintain a live link to the input elements.
   *
   * @default {}
   * @example <bim-panel></bim-panel> <!-- Access via JavaScript to get value -->
   * @example
   * const panel = document.createElement('bim-panel');
   * document.body.appendChild(panel);
   * console.log(panel.value); // Logs the current value object of the panel
   */
  get value() {
    return Be(this, this.valueTransform);
  }
  /**
   * The `value` setter allows programmatically updating the values of the panel's form elements. When a data object is passed to this property, it attempts to match the object's keys with the `name` or `label` attributes of the panel's child elements. If a match is found, the corresponding element's value is updated to the value associated with the key in the data object. This property is useful for initializing the panel with specific data or updating its state based on external inputs. Note that this operation does not affect elements without a matching `name` or `label`, and it only updates the values of elements that are direct children of the panel.
   *
   * @type {Record<string, any>}
   * @example <bim-panel></bim-panel> <!-- Set value via JavaScript -->
   * @example
   * const panel = document.createElement('bim-panel');
   * document.body.appendChild(panel);
   * panel.value = { 'input-name': 'John Doe', 'checkbox-name': true };
   */
  set value(t) {
    const e = [...this.children];
    for (const i in t) {
      const n = e.find((o) => {
        const a = o;
        return a.name === i || a.label === i;
      });
      if (!n)
        continue;
      const r = n;
      r.value = t[i];
    }
  }
  animatePanles() {
    const t = [
      {
        maxHeight: "100vh",
        maxWidth: "100vw",
        opacity: 1
      },
      {
        maxHeight: "100vh",
        maxWidth: "100vw",
        opacity: 0
      },
      {
        maxHeight: 0,
        maxWidth: 0,
        opacity: 0
      }
    ];
    this.animate(t, {
      duration: 300,
      easing: "cubic-bezier(0.65, 0.05, 0.36, 1)",
      direction: this.hidden ? "normal" : "reverse",
      fill: "forwards"
    });
  }
  connectedCallback() {
    super.connectedCallback(), this.activationButton.active = !this.hidden, this.activationButton.onclick = () => {
      this.hidden = !this.hidden, this.animatePanles();
    };
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.activationButton.remove();
  }
  /**
   * Collapses all `bim-panel-section` elements within the panel.
   * This method iterates over each `bim-panel-section` found within the panel's DOM and sets their `collapsed` property to `true`,
   * effectively hiding their content from view. This can be used to programmatically minimize the space taken up by sections
   * within the panel, making the panel more compact or to hide details that are not immediately necessary.
   */
  collapseSections() {
    const t = this.querySelectorAll("bim-panel-section");
    for (const e of t)
      e.collapsed = true;
  }
  /**
   * Expands all `bim-panel-section` elements within the panel.
   * This method iterates over each `bim-panel-section` found within the panel's DOM and sets their `collapsed` property to `false`,
   * effectively showing their content. This can be used to programmatically reveal the content of sections within the panel,
   * making the panel more informative or to display details that are necessary for the user.
   */
  expandSections() {
    const t = this.querySelectorAll("bim-panel-section");
    for (const e of t)
      e.collapsed = false;
  }
  render() {
    return this.activationButton.icon = this.icon, this.activationButton.label = this.label || this.name, this.activationButton.tooltipTitle = this.label || this.name, f`
      <div class="parent">
        ${this.label || this.name || this.icon ? f`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
        <div class="sections">
          <slot></slot>
        </div>
      </div>
    `;
  }
};
Xi.styles = [
  xt.scrollbar,
  S`
      :host {
        display: flex;
        border-radius: var(--bim-ui_size-base);
        background-color: var(--bim-ui_bg-base);
        overflow: auto;
      }

      :host([hidden]) {
        max-height: 0;
        max-width: 0;
        opacity: 0;
      }

      .parent {
        display: flex;
        flex: 1;
        flex-direction: column;
        pointer-events: auto;
        overflow: auto;
      }

      .parent bim-label {
        --bim-label--c: var(--bim-panel--c, var(--bim-ui_bg-contrast-80));
        --bim-label--fz: var(--bim-panel--fz, var(--bim-ui_size-sm));
        font-weight: 600;
        padding: 1rem;
        flex-shrink: 0;
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([header-hidden]) .parent bim-label {
        display: none;
      }

      .sections {
        height: 100%;
        display: flex;
        flex-direction: column;
        overflow: auto;
        flex: 1;
      }

      ::slotted(bim-panel-section:not(:last-child)) {
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }
    `
];
var ot = Xi;
_e([
  d({ type: String, reflect: true })
], ot.prototype, "icon", 2);
_e([
  d({ type: String, reflect: true })
], ot.prototype, "name", 2);
_e([
  d({ type: String, reflect: true })
], ot.prototype, "label", 2);
_e([
  d({ type: Boolean, reflect: true })
], ot.prototype, "hidden", 1);
_e([
  d({ type: Boolean, attribute: "header-hidden", reflect: true })
], ot.prototype, "headerHidden", 2);
var Fa = Object.defineProperty;
var we = (s, t, e, i) => {
  for (var n = void 0, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (n = o(t, e, n) || n);
  return n && Fa(t, e, n), n;
};
var Zi = class Zi2 extends C {
  constructor() {
    super(...arguments), this.onValueChange = new Event("change"), this.valueTransform = {}, this.componentHeight = -1;
  }
  /**
   * The `value` getter computes and returns the current state of the panel section's form elements as an object. This object's keys are the `name` or `label` attributes of the child elements, and the values are the corresponding values of these elements. This property is particularly useful for retrieving a consolidated view of the user's input or selections within the panel section. When the value of any child element changes, the returned object from this getter will reflect those changes, providing a dynamic snapshot of the panel section's state. Note that this property does not have a default value as it dynamically reflects the current state of the panel section's form elements.
   * @example <bim-panel-section></bim-panel-section> <!-- Usage in HTML not directly applicable as this is a getter -->
   * @example
   * const section = document.createElement('bim-panel-section');
   * console.log(section.value); // Logs the current value object
   */
  get value() {
    const t = this.parentElement;
    let e;
    return t instanceof ot && (e = t.valueTransform), Object.values(this.valueTransform).length !== 0 && (e = this.valueTransform), Be(this, e);
  }
  /**
   * The `value` setter allows programmatically updating the values of the panel section's child elements. It accepts an object where keys correspond to the `name` or `label` attributes of the child elements, and the values are the new values to be set for these elements. This property is useful for initializing the panel section with specific values or updating its state based on external data. When the property changes, the corresponding child elements' values are updated to reflect the new state. This does not have a default value as it is a method for updating child elements' values.
   * @type {Record<string, any>}
   * @default undefined
   * @example <bim-panel-section></bim-panel-section> <!-- Usage in HTML not directly applicable as this is a setter -->
   * @example
   * const section = document.createElement('bim-panel-section');
   * section.value = { 'user-settings': 'John Doe' }; // Programmatically sets the value of a child element named 'user-settings'
   */
  set value(t) {
    const e = [...this.children];
    for (const i in t) {
      const n = e.find((o) => {
        const a = o;
        return a.name === i || a.label === i;
      });
      if (!n)
        continue;
      const r = n;
      r.value = t[i];
    }
  }
  setFlexAfterTransition() {
    var e;
    const t = (e = this.shadowRoot) == null ? void 0 : e.querySelector(
      ".components"
    );
    t && setTimeout(() => {
      this.collapsed ? t.style.removeProperty("flex") : t.style.setProperty("flex", "1");
    }, 150);
  }
  animateHeader() {
    var e;
    const t = (e = this.shadowRoot) == null ? void 0 : e.querySelector(
      ".components"
    );
    this.componentHeight < 0 && (this.collapsed ? this.componentHeight = t.clientHeight : (t.style.setProperty("transition", "none"), t.style.setProperty("height", "auto"), t.style.setProperty("padding", "0.125rem 1rem 1rem"), this.componentHeight = t.clientHeight, requestAnimationFrame(() => {
      t.style.setProperty("height", "0px"), t.style.setProperty("padding", "0 1rem 0"), t.style.setProperty(
        "transition",
        "height 0.25s cubic-bezier(0.65, 0.05, 0.36, 1), padding 0.25s cubic-bezier(0.65, 0.05, 0.36, 1)"
      );
    }))), this.collapsed ? (t.style.setProperty(
      "height",
      `${this.componentHeight}px`
    ), requestAnimationFrame(() => {
      t.style.setProperty("height", "0px"), t.style.setProperty("padding", "0 1rem 0");
    })) : (t.style.setProperty("height", "0px"), t.style.setProperty("padding", "0 1rem 0"), requestAnimationFrame(() => {
      t.style.setProperty(
        "height",
        `${this.componentHeight}px`
      ), t.style.setProperty("padding", "0.125rem 1rem 1rem");
    })), this.setFlexAfterTransition();
  }
  onHeaderClick() {
    this.fixed || (this.collapsed = !this.collapsed, this.animateHeader());
  }
  handelSlotChange(t) {
    t.target.assignedElements({ flatten: true }).forEach((n, r) => {
      const o = r * 0.05;
      n.style.setProperty("transition-delay", `${o}s`);
    });
  }
  handlePointerEnter() {
    const t = this.renderRoot.querySelector(".expand-icon");
    this.collapsed ? t == null || t.style.setProperty("animation", "collapseAnim 0.5s") : t == null || t.style.setProperty("animation", "expandAnim 0.5s");
  }
  handlePointerLeave() {
    const t = this.renderRoot.querySelector(".expand-icon");
    t == null || t.style.setProperty("animation", "none");
  }
  render() {
    const t = this.label || this.icon || this.name || this.fixed, e = f`<svg
      xmlns="http://www.w3.org/2000/svg"
      height="1.125rem"
      viewBox="0 0 24 24"
      width="1.125rem"
      class="expand-icon"
    >
      <path d="M0 0h24v24H0z" fill="none" />
      <path d="M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z" />
    </svg>`, i = f`
      <div
        class="header"
        title=${this.label ?? ""}
        @pointerenter=${this.handlePointerEnter}
        @pointerleave=${this.handlePointerLeave}
        @click=${this.onHeaderClick}
      >
        ${this.label || this.icon || this.name ? f`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
        ${this.fixed ? null : e}
      </div>
    `;
    return f`
      <div class="parent">
        ${t ? i : null}
        <div class="components" style="flex: 1;">
          <div>
            <slot @slotchange=${this.handelSlotChange}></slot>
          </div>
        </div>
      </div>
    `;
  }
};
Zi.styles = [
  xt.scrollbar,
  S`
      :host {
        display: block;
        pointer-events: auto;
      }

      :host .parent {
        display: flex;
        flex-direction: column;
        height: 100%;
      }

      :host(:not([fixed])) .header:hover {
        --bim-label--c: var(--bim-ui_accent-base);
        color: var(--bim-ui_accent-base);
        cursor: pointer;
      }

      :host(:not([fixed])) .header:hover .expand-icon {
        fill: var(--bim-ui_accent-base);
      }

      .header {
        --bim-label--fz: var(--bim-ui_size-sm);
        --bim-label--c: var(
          --bim-panel-section_hc,
          var(--bim-ui_bg-contrast-80)
        );
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        height: 1.5rem;
        padding: 0.75rem 1rem;
      }

      .expand-icon {
        fill: var(--bim-ui_bg-contrast-80);
        transition: transform 0.2s;
      }

      :host([collapsed]) .expand-icon {
        transform: rotateZ(-180deg);
      }

      .title {
        display: flex;
        align-items: center;
        column-gap: 0.5rem;
      }

      .title p {
        font-size: var(--bim-ui_size-sm);
      }

      .components {
        display: flex;
        flex-direction: column;
        overflow: hidden;
        row-gap: 0.75rem;
        padding: 0 1rem 1rem;
        box-sizing: border-box;
        transition:
          height 0.25s cubic-bezier(0.65, 0.05, 0.36, 1),
          padding 0.25s cubic-bezier(0.65, 0.05, 0.36, 1);
      }

      .components > div {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        flex: 1;
        overflow: auto;
      }

      :host(:not([icon]):not([label])) .components {
        padding: 1rem;
      }

      :host(:not([fixed])[collapsed]) .components {
        padding: 0 1rem 0;
        height: 0px;
      }

      bim-label {
        pointer-events: none;
      }

      ::slotted(*) {
        transition:
          transform 0.25s cubic-bezier(0.65, 0.05, 0.36, 1),
          opacity 0.25s cubic-bezier(0.65, 0.05, 0.36, 1);
      }

      :host(:not([fixed])[collapsed]) ::slotted(*) {
        transform: translateX(-20%);
        opacity: 0;
      }

      @keyframes expandAnim {
        0%,
        100% {
          transform: translateY(0%);
        }
        25% {
          transform: translateY(-30%);
        }
        50% {
          transform: translateY(10%);
        }
        75% {
          transform: translateY(-30%);
        }
      }

      @keyframes collapseAnim {
        0%,
        100% {
          transform: translateY(0%) rotateZ(-180deg);
        }
        25% {
          transform: translateY(30%) rotateZ(-180deg);
        }
        50% {
          transform: translateY(-10%) rotateZ(-180deg);
        }
        75% {
          transform: translateY(30%) rotateZ(-180deg);
        }
      }
    `
];
var vt = Zi;
we([
  d({ type: String, reflect: true })
], vt.prototype, "icon");
we([
  d({ type: String, reflect: true })
], vt.prototype, "label");
we([
  d({ type: String, reflect: true })
], vt.prototype, "name");
we([
  d({ type: Boolean, reflect: true })
], vt.prototype, "fixed");
we([
  d({ type: Boolean, reflect: true })
], vt.prototype, "collapsed");
var Na = Object.defineProperty;
var xe = (s, t, e, i) => {
  for (var n = void 0, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (n = o(t, e, n) || n);
  return n && Na(t, e, n), n;
};
var Ji = class Ji2 extends C {
  constructor() {
    super(...arguments), this.vertical = false, this.onValueChange = new Event("change"), this._canEmitEvents = false, this._value = document.createElement("bim-option"), this.onOptionClick = (t) => {
      this._value = t.target, this.setAnimatedBackgound(), this.dispatchEvent(this.onValueChange);
      for (const e of this.children)
        e instanceof T && (e.checked = e === t.target);
    };
  }
  get _options() {
    return [...this.querySelectorAll("bim-option")];
  }
  /**
   * Sets the value of the selector.
   * It finds the matching option based on the provided value and sets it as the selected option.
   * If no matching option is found, it does nothing.
   *
   * @param value - The value to set for the selector.
   */
  set value(t) {
    const e = this.findOption(t);
    if (e) {
      for (const i of this._options)
        i.checked = i === e;
      this._value = e, this.setAnimatedBackgound(), this._canEmitEvents && this.dispatchEvent(this.onValueChange);
    }
  }
  get value() {
    return this._value.value;
  }
  onSlotChange(t) {
    const e = t.target.assignedElements();
    for (const i of e)
      i instanceof T && (i.noMark = true, i.removeEventListener("click", this.onOptionClick), i.addEventListener("click", this.onOptionClick));
  }
  findOption(t) {
    return this._options.find((i) => i instanceof T ? i.label === t || i.value === t : false);
  }
  doubleRequestAnimationFrames(t) {
    requestAnimationFrame(() => requestAnimationFrame(t));
  }
  setAnimatedBackgound(t = false) {
    const e = this.renderRoot.querySelector(
      ".animated-background"
    ), i = this._value;
    requestAnimationFrame(() => {
      var o, a, l, c;
      const n = (c = (l = (a = (o = i == null ? void 0 : i.parentElement) == null ? void 0 : o.shadowRoot) == null ? void 0 : a.querySelector("bim-input")) == null ? void 0 : l.shadowRoot) == null ? void 0 : c.querySelector(".input"), r = {
        width: i == null ? void 0 : i.clientWidth,
        height: i == null ? void 0 : i.clientHeight,
        top: ((i == null ? void 0 : i.offsetTop) ?? 0) - ((n == null ? void 0 : n.offsetTop) ?? 0),
        left: ((i == null ? void 0 : i.offsetLeft) ?? 0) - ((n == null ? void 0 : n.offsetLeft) ?? 0)
      };
      e == null || e.style.setProperty("width", `${r.width}px`), e == null || e.style.setProperty("height", `${r.height}px`), e == null || e.style.setProperty("top", `${r.top}px`), e == null || e.style.setProperty("left", `${r.left}px`);
    }), t && this.doubleRequestAnimationFrames(() => {
      const r = "ease";
      e == null || e.style.setProperty(
        "transition",
        `width ${0.3}s ${r}, height ${0.3}s ${r}, top ${0.3}s ${r}, left ${0.3}s ${r}`
      );
    });
  }
  firstUpdated() {
    const t = [...this.children].find(
      (e) => e instanceof T && e.checked
    );
    t && (this._value = t), window.addEventListener("load", () => {
      this.setAnimatedBackgound(true);
    }), new ResizeObserver(() => {
      this.setAnimatedBackgound();
    }).observe(this);
  }
  render() {
    return f`
      <bim-input
        .vertical=${this.vertical}
        .label=${this.label}
        .icon=${this.icon}
      >
        <div class="animated-background"></div>
        <slot @slotchange=${this.onSlotChange}></slot>
      </bim-input>
    `;
  }
};
Ji.styles = S`
    :host {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
      --bim-input--g: 0;
      --bim-option--jc: center;
      flex: 1;
      display: block;
    }

    ::slotted(bim-option) {
      position: relative;
      border-radius: 0;
      overflow: hidden;
      min-width: min-content;
      min-height: min-content;
      transition: background-color 0.2s;
    }

    .animated-background {
      position: absolute;
      background: var(--bim-ui_main-base);
      width: 0;
      height: 0;
      top: 0;
      left: 0;
    }

    ::slotted(bim-option[checked]) {
      --bim-label--c: var(--bim-ui_main-contrast);
    }

    ::slotted(bim-option:not([checked]):hover) {
      background-color: #0003;
    }
  `;
var yt = Ji;
xe([
  d({ type: String, reflect: true })
], yt.prototype, "name");
xe([
  d({ type: String, reflect: true })
], yt.prototype, "icon");
xe([
  d({ type: String, reflect: true })
], yt.prototype, "label");
xe([
  d({ type: Boolean, reflect: true })
], yt.prototype, "vertical");
xe([
  Lt()
], yt.prototype, "_value");
var qa = () => f`
    <style>
      div {
        display: flex;
        gap: 0.375rem;
        border-radius: 0.25rem;
        min-height: 1.25rem;
      }

      [data-type="row"] {
        background-color: var(--bim-ui_bg-contrast-10);
        animation: row-loading 1s linear infinite alternate;
        padding: 0.5rem;
      }

      [data-type="cell"] {
        background-color: var(--bim-ui_bg-contrast-20);
        flex: 0.25;
      }

      @keyframes row-loading {
        0% {
          background-color: var(--bim-ui_bg-contrast-10);
        }
        100% {
          background-color: var(--bim-ui_bg-contrast-20);
        }
      }
    </style>
    <div style="display: flex; flex-direction: column;">
      <div data-type="row" style="gap: 2rem">
        <div data-type="cell" style="flex: 1"></div>
        <div data-type="cell" style="flex: 2"></div>
        <div data-type="cell" style="flex: 1"></div>
        <div data-type="cell" style="flex: 0.5"></div>
      </div>
      <div style="display: flex;">
        <div data-type="row" style="flex: 1">
          <div data-type="cell" style="flex: 0.5"></div>
        </div>
        <div data-type="row" style="flex: 2">
          <div data-type="cell" style="flex: 0.75"></div>
        </div>
        <div data-type="row" style="flex: 1">
          <div data-type="cell"></div>
        </div>
        <div data-type="row" style="flex: 0.5">
          <div data-type="cell" style="flex: 0.75"></div>
        </div>
      </div>
      <div style="display: flex;">
        <div data-type="row" style="flex: 1">
          <div data-type="cell" style="flex: 0.75"></div>
        </div>
        <div data-type="row" style="flex: 2">
          <div data-type="cell"></div>
        </div>
        <div data-type="row" style="flex: 1">
          <div data-type="cell" style="flex: 0.5"></div>
        </div>
        <div data-type="row" style="flex: 0.5">
          <div data-type="cell" style="flex: 0.5"></div>
        </div>
      </div>
      <div style="display: flex;">
        <div data-type="row" style="flex: 1">
          <div data-type="cell"></div>
        </div>
        <div data-type="row" style="flex: 2">
          <div data-type="cell" style="flex: 0.5"></div>
        </div>
        <div data-type="row" style="flex: 1">
          <div data-type="cell" style="flex: 0.75"></div>
        </div>
        <div data-type="row" style="flex: 0.5">
          <div data-type="cell" style="flex: 0.7s5"></div>
        </div>
      </div>
    </div>
  `;
var Va = () => f`
    <style>
      .loader {
        grid-area: Processing;
        position: relative;
        padding: 0.125rem;
      }
      .loader:before {
        content: "";
        position: absolute;
      }
      .loader .loaderBar {
        position: absolute;
        top: 0;
        right: 100%;
        bottom: 0;
        left: 0;
        background: var(--bim-ui_main-base);
        /* width: 25%; */
        width: 0;
        animation: borealisBar 2s linear infinite;
      }

      @keyframes borealisBar {
        0% {
          left: 0%;
          right: 100%;
          width: 0%;
        }
        10% {
          left: 0%;
          right: 75%;
          width: 25%;
        }
        90% {
          right: 0%;
          left: 75%;
          width: 25%;
        }
        100% {
          left: 100%;
          right: 0%;
          width: 0%;
        }
      }
    </style>
    <div class="loader">
      <div class="loaderBar"></div>
    </div>
  `;
var Ua = Object.defineProperty;
var Wa = (s, t, e, i) => {
  for (var n = void 0, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (n = o(t, e, n) || n);
  return n && Ua(t, e, n), n;
};
var tn = class tn2 extends C {
  constructor() {
    super(...arguments), this.column = "", this.columnIndex = 0, this.table = null, this.group = null, this.row = null, this.rowData = {};
  }
  get data() {
    return this.column ? this.rowData[this.column] : null;
  }
  get dataTransform() {
    var n, r, o, a;
    const t = (r = (n = this.row) == null ? void 0 : n.dataTransform) == null ? void 0 : r[this.column], e = (o = this.table) == null ? void 0 : o.dataTransform[this.column], i = (a = this.table) == null ? void 0 : a.defaultContentTemplate;
    return t || e || i;
  }
  get templateValue() {
    const { data: t, rowData: e, group: i } = this, n = this.dataTransform;
    if (n && t != null && i) {
      const r = n(t, e, i);
      return typeof r == "string" || typeof r == "boolean" || typeof r == "number" ? f`<bim-label>${r}</bim-label>` : r;
    }
    return t != null ? f`<bim-label>${t}</bim-label>` : E;
  }
  connectedCallback() {
    super.connectedCallback(), this.style.gridArea = this.column.toString();
  }
  render() {
    return f`${this.templateValue}`;
  }
};
tn.styles = S`
    :host {
      padding: 0.375rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    :host([data-column-index="0"]) {
      justify-content: normal;
    }

    :host([data-column-index="0"]:not([data-cell-header]))
      ::slotted(bim-label) {
      text-align: left;
    }

    ::slotted(*) {
      --bim-input--bgc: transparent;
      --bim-input--olc: var(--bim-ui_bg-contrast-20);
      --bim-input--olw: 1px;
    }

    ::slotted(bim-input) {
      --bim-input--olw: 0;
    }
  `;
var Me = tn;
Wa([
  d({ type: String, reflect: true })
], Me.prototype, "column");
var en = class en2 extends C {
  constructor() {
    super(...arguments), this._groups = [], this.group = this.closest("bim-table-group"), this._data = [], this.table = this.closest("bim-table");
  }
  get data() {
    var t;
    return ((t = this.group) == null ? void 0 : t.data.children) ?? this._data;
  }
  set data(t) {
    this._data = t;
  }
  clean() {
    for (const t of this._groups)
      t.remove();
    this._groups = [];
  }
  render() {
    return this.clean(), f`
      <slot></slot>
      ${this.data.map((t) => {
      const e = document.createElement(
        "bim-table-group"
      );
      return this._groups.push(e), e.table = this.table, e.data = t, e;
    })}
    `;
  }
};
en.styles = S`
    :host {
      --bim-button--bgc: transparent;
      position: relative;
      display: block;
      overflow: hidden;
      grid-area: Children;
    }

    :host([hidden]) {
      height: 0;
      opacity: 0;
    }

    ::slotted(.branch.branch-vertical) {
      top: 0;
      bottom: 1.125rem;
    }
  `;
var xi = en;
var Gs = "important";
var Ya = " !" + Gs;
var Xn = ws(class extends xs {
  constructor(s) {
    var t;
    if (super(s), s.type !== _s.ATTRIBUTE || s.name !== "style" || ((t = s.strings) == null ? void 0 : t.length) > 2)
      throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(s) {
    return Object.keys(s).reduce((t, e) => {
      const i = s[e];
      return i == null ? t : t + `${e = e.includes("-") ? e : e.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${i};`;
    }, "");
  }
  update(s, [t]) {
    const { style: e } = s.element;
    if (this.ft === void 0)
      return this.ft = new Set(Object.keys(t)), this.render(t);
    for (const i of this.ft)
      t[i] == null && (this.ft.delete(i), i.includes("-") ? e.removeProperty(i) : e[i] = null);
    for (const i in t) {
      const n = t[i];
      if (n != null) {
        this.ft.add(i);
        const r = typeof n == "string" && n.endsWith(Ya);
        i.includes("-") || r ? e.setProperty(i, r ? n.slice(0, -11) : n, r ? Gs : "") : e[i] = n;
      }
    }
    return Ot;
  }
});
var Ga = Object.defineProperty;
var Qa = (s, t, e, i) => {
  for (var n = void 0, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (n = o(t, e, n) || n);
  return n && Ga(t, e, n), n;
};
var nn = class nn2 extends C {
  constructor() {
    super(...arguments), this.childrenHidden = true, this.table = null, this.data = { data: {} };
  }
  get rowElement() {
    const t = this.shadowRoot;
    return t ? t.querySelector("bim-table-row") : null;
  }
  get childrenElement() {
    const t = this.shadowRoot;
    return t ? t.querySelector("bim-table-children") : null;
  }
  get _isChildrenEmpty() {
    return !(this.data.children && this.data.children.length !== 0);
  }
  connectedCallback() {
    super.connectedCallback(), this.table && this.table.expanded ? this.childrenHidden = false : this.childrenHidden = true;
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.data = { data: {} };
  }
  toggleChildren(t) {
    this.childrenHidden = typeof t > "u" ? !this.childrenHidden : !t, this.animateTableChildren(true);
  }
  animateTableChildren(t = true) {
    if (!t) {
      requestAnimationFrame(() => {
        var c;
        const o = this.renderRoot.querySelector(".caret"), a = this.renderRoot.querySelector(
          ".branch-vertical"
        ), l = (c = this.renderRoot.querySelector("bim-table-children")) == null ? void 0 : c.querySelector(".branch-vertical");
        o.style.setProperty(
          "transform",
          `translateY(-50%) rotate(${this.childrenHidden ? "0" : "90"}deg)`
        ), a.style.setProperty(
          "transform",
          `scaleY(${this.childrenHidden ? "0" : "1"})`
        ), l == null || l.style.setProperty(
          "transform",
          `scaleY(${this.childrenHidden ? "0" : "1"})`
        );
      });
      return;
    }
    const e = 500, i = 0, n = 200, r = 350;
    requestAnimationFrame(() => {
      var v;
      const o = this.renderRoot.querySelector("bim-table-children"), a = this.renderRoot.querySelector(".caret"), l = this.renderRoot.querySelector(
        ".branch-vertical"
      ), c = (v = this.renderRoot.querySelector("bim-table-children")) == null ? void 0 : v.querySelector(".branch-vertical"), u = () => {
        var w;
        const b = (w = o == null ? void 0 : o.renderRoot) == null ? void 0 : w.querySelectorAll("bim-table-group");
        b == null || b.forEach((y, x) => {
          y.style.setProperty("opacity", "0"), y.style.setProperty("left", "-30px");
          const A = [
            {
              opacity: "0",
              left: "-30px"
            },
            {
              opacity: "1",
              left: "0"
            }
          ];
          y.animate(A, {
            duration: e / 2,
            delay: 50 + x * i,
            easing: "cubic-bezier(0.65, 0.05, 0.36, 1)",
            fill: "forwards"
          });
        });
      }, h = () => {
        const b = [
          { transform: "translateY(-50%) rotate(90deg)" },
          { transform: "translateY(-50%) rotate(0deg)" }
        ];
        a == null || a.animate(b, {
          duration: r,
          easing: "cubic-bezier(0.68, -0.55, 0.27, 1.55)",
          fill: "forwards",
          direction: this.childrenHidden ? "normal" : "reverse"
        });
      }, p = () => {
        const b = [
          { transform: "scaleY(1)" },
          { transform: "scaleY(0)" }
        ];
        l == null || l.animate(b, {
          duration: n,
          easing: "cubic-bezier(0.4, 0, 0.2, 1)",
          delay: i,
          fill: "forwards",
          direction: this.childrenHidden ? "normal" : "reverse"
        });
      }, m = () => {
        var w;
        const b = (w = this.renderRoot.querySelector("bim-table-row")) == null ? void 0 : w.querySelector(".branch-horizontal");
        if (b) {
          b.style.setProperty("transform-origin", "center right");
          const y = [
            { transform: "scaleX(0)" },
            { transform: "scaleX(1)" }
          ];
          b.animate(y, {
            duration: n,
            easing: "cubic-bezier(0.4, 0, 0.2, 1)",
            fill: "forwards",
            direction: this.childrenHidden ? "normal" : "reverse"
          });
        }
      }, g = () => {
        const b = [
          { transform: "scaleY(0)" },
          { transform: "scaleY(1)" }
        ];
        c == null || c.animate(b, {
          duration: n * 1.2,
          easing: "cubic-bezier(0.4, 0, 0.2, 1)",
          fill: "forwards",
          delay: (i + n) * 0.7
        });
      };
      u(), h(), p(), m(), g();
    });
  }
  firstUpdated() {
    this.renderRoot.querySelectorAll(".caret").forEach((e) => {
      var i, n, r;
      if (!this.childrenHidden) {
        e.style.setProperty(
          "transform",
          "translateY(-50%) rotate(90deg)"
        );
        const a = (i = e.parentElement) == null ? void 0 : i.querySelector(
          ".branch-horizontal"
        );
        a && a.style.setProperty("transform", "scaleX(0)");
        const l = (r = (n = e.parentElement) == null ? void 0 : n.parentElement) == null ? void 0 : r.querySelectorAll(
          ".branch-vertical"
        );
        l == null || l.forEach((c) => {
          c.style.setProperty("transform", "scaleY(1)");
        });
      }
    });
  }
  render() {
    if (!this.table)
      return f`${E}`;
    const t = this.table.getGroupIndentation(this.data) ?? 0;
    let e;
    if (!this.table.noIndentation) {
      const a = { left: `${t - 1 + (this.table.selectableRows ? 2.05 : 0.5625)}rem` };
      e = f`<div style=${Xn(a)} class="branch branch-horizontal"></div>`;
    }
    const i = f`
      ${this.table.noIndentation ? null : f`
            <style>
              .branch-vertical {
                left: ${t + (this.table.selectableRows ? 1.9375 : 0.5625)}rem;
              }
            </style>
            <div class="branch branch-vertical"></div>
          `}
    `;
    let n;
    if (!this.table.noIndentation) {
      const a = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "svg"
      );
      if (a.setAttribute("height", "9.9"), a.setAttribute("width", "7.5"), a.setAttribute("viewBox", "0 0 4.6666672 7.7"), this.table.noCarets) {
        const u = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "circle"
        );
        u.setAttribute("cx", "2.3333336"), u.setAttribute("cy", "3.85"), u.setAttribute("r", "2.5"), a.append(u);
      } else {
        const u = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "path"
        );
        u.setAttribute(
          "d",
          "m 1.7470835,6.9583848 2.5899999,-2.59 c 0.39,-0.39 0.39,-1.02 0,-1.41 L 1.7470835,0.36838483 c -0.63,-0.62000003 -1.71000005,-0.18 -1.71000005,0.70999997 v 5.17 c 0,0.9 1.08000005,1.34 1.71000005,0.71 z"
        ), a.append(u);
      }
      const l = {
        left: `${(this.table.selectableRows ? 1.5 : 0.125) + t}rem`,
        cursor: `${this.table.noCarets ? "unset" : "pointer"}`
      };
      n = f`<div @click=${(u) => {
        var h;
        (h = this.table) != null && h.noCarets || (u.stopPropagation(), this.toggleChildren());
      }} style=${Xn(l)} class="caret">${a}</div>`;
    }
    let r;
    return !this._isChildrenEmpty && !this.childrenHidden && (r = f`
        <bim-table-children ${J((l) => {
      if (!l)
        return;
      const c = l;
      c.table = this.table, c.group = this;
    })}>${i}</bim-table-children>
      `), f`
      <div class="parent">
        <bim-table-row ${J((a) => {
      var c;
      if (!a)
        return;
      const l = a;
      l.table = this.table, l.group = this, (c = this.table) == null || c.dispatchEvent(
        new CustomEvent("rowcreated", {
          detail: { row: l }
        })
      );
    })}>
          ${Dt(!this._isChildrenEmpty, () => i)}
          ${Dt(t !== 0, () => e)}
          ${Dt(!this.table.noIndentation && !this._isChildrenEmpty, () => n)}
        </bim-table-row>
        ${r}
      </div>
    `;
  }
};
nn.styles = S`
    :host {
      position: relative;
    }

    .parent {
      display: grid;
      grid-template-areas: "Data" "Children";
    }

    .branch {
      position: absolute;
      z-index: 1;
    }

    .branch-vertical {
      border-left: 1px dotted var(--bim-ui_bg-contrast-40);
      transform-origin: top center;
      transform: scaleY(0);
    }

    .branch-horizontal {
      top: 50%;
      width: 1rem;
      border-bottom: 1px dotted var(--bim-ui_bg-contrast-40);
    }

    .branch-horizontal {
      transform-origin: center left;
    }

    .caret {
      position: absolute;
      z-index: 2;
      transform: translateY(-50%) rotate(0deg);
      top: 50%;
      display: flex;
      width: 0.95rem;
      height: 0.95rem;
      justify-content: center;
      align-items: center;
    }

    .caret svg {
      fill: var(--bim-ui_bg-contrast-60);
    }
  `;
var je = nn;
Qa([
  d({ type: Boolean, attribute: "children-hidden", reflect: true })
], je.prototype, "childrenHidden");
var Ka = Object.defineProperty;
var Gt = (s, t, e, i) => {
  for (var n = void 0, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (n = o(t, e, n) || n);
  return n && Ka(t, e, n), n;
};
var sn = class sn2 extends C {
  constructor() {
    super(...arguments), this.selected = false, this.columns = [], this.hiddenColumns = [], this.group = null, this._data = {}, this.isHeader = false, this.table = null, this.onTableColumnsChange = () => {
      this.table && (this.columns = this.table.columns);
    }, this.onTableColumnsHidden = () => {
      this.table && (this.hiddenColumns = this.table.hiddenColumns);
    }, this._intersecting = false, this._timeOutDelay = 250, this._observer = new IntersectionObserver(
      (t) => {
        window.clearTimeout(this._intersectTimeout), this._intersectTimeout = void 0, t[0].isIntersecting ? this._intersectTimeout = window.setTimeout(() => {
          this._intersecting = true;
        }, this._timeOutDelay) : this._intersecting = false;
      },
      { rootMargin: "36px" }
    ), this.dataTransform = null, this._interval = null, this.clearDataTransform = () => {
      this.dataTransform = null, this._interval !== null && (clearInterval(this._interval), this._interval = null);
    }, this._cache = {};
  }
  get groupData() {
    var t;
    return (t = this.group) == null ? void 0 : t.data;
  }
  get data() {
    var t;
    return ((t = this.group) == null ? void 0 : t.data.data) ?? this._data;
  }
  set data(t) {
    this._data = t;
  }
  get _columnNames() {
    return this.columns.filter(
      (i) => !this.hiddenColumns.includes(i.name)
    ).map((i) => i.name);
  }
  get _columnWidths() {
    return this.columns.filter(
      (i) => !this.hiddenColumns.includes(i.name)
    ).map((i) => i.width);
  }
  get _isSelected() {
    var t;
    return (t = this.table) == null ? void 0 : t.selection.has(this.data);
  }
  onSelectionChange(t) {
    if (!this.table)
      return;
    const e = t.target;
    this.selected = e.value, e.value ? (this.table.selection.add(this.data), this.table.dispatchEvent(
      new CustomEvent("rowselected", {
        detail: {
          data: this.data
        }
      })
    )) : (this.table.selection.delete(this.data), this.table.dispatchEvent(
      new CustomEvent("rowdeselected", {
        detail: {
          data: this.data
        }
      })
    ));
  }
  firstUpdated(t) {
    super.firstUpdated(t), this._observer.observe(this);
  }
  connectedCallback() {
    super.connectedCallback(), this.toggleAttribute("selected", this._isSelected), this.table && (this.columns = this.table.columns, this.hiddenColumns = this.table.hiddenColumns, this.table.addEventListener("columnschange", this.onTableColumnsChange), this.table.addEventListener("columnshidden", this.onTableColumnsHidden), this.style.gridTemplateAreas = `"${this.table.selectableRows ? "Selection" : ""} ${this._columnNames.join(" ")}"`, this.style.gridTemplateColumns = `${this.table.selectableRows ? "1.6rem" : ""} ${this._columnWidths.join(" ")}`);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._observer.unobserve(this), this.columns = [], this.hiddenColumns = [], this.toggleAttribute("selected", false), this.data = {}, this.table && (this.table.removeEventListener("columnschange", this.onTableColumnsChange), this.table.removeEventListener("columnshidden", this.onTableColumnsHidden), this.table = null), this.clean();
  }
  applyAdaptativeDataTransform(t) {
    this.addEventListener("pointerenter", () => {
      this.dataTransform = t, this._interval = window.setInterval(() => {
        this.matches(":hover") || this.clearDataTransform();
      }, 50);
    });
  }
  clean() {
    clearTimeout(this._intersectTimeout), this._intersectTimeout = void 0, this._timeOutDelay = 250;
    for (const [, t] of Object.entries(this._cache))
      t.remove();
    this._cache = {};
  }
  render() {
    if (!(this.table && this._intersecting))
      return f`${E}`;
    const t = this.table.getRowIndentation(this.data) ?? 0, e = [];
    for (const i in this.data) {
      if (this.hiddenColumns.includes(i))
        continue;
      const n = document.createElement("bim-table-cell");
      n.group = this.group, n.table = this.table, n.row = this, n.column = i, this._columnNames.indexOf(i) === 0 && (n.style.marginLeft = `${this.table.noIndentation ? 0 : t + 0.75}rem`);
      const r = this._columnNames.indexOf(i);
      n.setAttribute("data-column-index", String(r)), n.toggleAttribute(
        "data-no-indentation",
        r === 0 && this.table.noIndentation
      ), n.toggleAttribute("data-cell-header", this.isHeader), n.rowData = this.data, this.table.dispatchEvent(
        new CustomEvent("cellcreated", {
          detail: { cell: n }
        })
      ), e.push(n);
    }
    return this._timeOutDelay = 0, f`
      ${!this.isHeader && this.table.selectableRows ? f`<bim-checkbox
            @change=${this.onSelectionChange}
            .checked=${this._isSelected ?? false}
            style="align-self: center; justify-self: center"
          ></bim-checkbox>` : null}
      ${e}
      <slot></slot>
    `;
  }
};
sn.styles = S`
    :host {
      position: relative;
      grid-area: Data;
      display: grid;
      min-height: 2.25rem;
      transition: all 0.15s;
    }

    ::slotted(.branch.branch-vertical) {
      top: 50%;
      bottom: 0;
    }

    :host([selected]) {
      background-color: color-mix(
        in lab,
        var(--bim-ui_bg-contrast-20) 30%,
        var(--bim-ui_accent-base) 10%
      );
    }
  `;
var at = sn;
Gt([
  d({ type: Boolean, reflect: true })
], at.prototype, "selected");
Gt([
  d({ attribute: false })
], at.prototype, "columns");
Gt([
  d({ attribute: false })
], at.prototype, "hiddenColumns");
Gt([
  d({ type: Boolean, attribute: "is-header", reflect: true })
], at.prototype, "isHeader");
Gt([
  Lt()
], at.prototype, "_intersecting");
Gt([
  Lt()
], at.prototype, "dataTransform");
var Xa = Object.defineProperty;
var Za = Object.getOwnPropertyDescriptor;
var V = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? Za(t, e) : t, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (n = (i ? o(t, e, n) : o(n)) || n);
  return i && n && Xa(t, e, n), n;
};
var rn = class rn2 extends C {
  constructor() {
    super(...arguments), this._filteredData = [], this.headersHidden = false, this.minColWidth = "4rem", this._columns = [], this._textDelimiters = {
      comma: ",",
      tab: "	"
    }, this._queryString = null, this._data = [], this.expanded = false, this.preserveStructureOnFilter = false, this.indentationInText = false, this.dataTransform = {}, this.selectableRows = false, this.selection = /* @__PURE__ */ new Set(), this.noIndentation = false, this.noCarets = false, this.loading = false, this._errorLoading = false, this._onColumnsHidden = new Event("columnshidden"), this._hiddenColumns = [], this.defaultContentTemplate = (t) => f`<bim-label style="white-space: normal; user-select: text;">${t}</bim-label>`, this._stringFilterFunction = (t, e) => Object.values(e.data).some((n) => String(n).toLowerCase().includes(t.toLowerCase())), this._queryFilterFunction = (t, e) => {
      let i = false;
      const n = yi(t) ?? [];
      for (const r of n) {
        if ("queries" in r) {
          i = false;
          break;
        }
        const { condition: o, value: a } = r;
        let { key: l } = r;
        if (l.startsWith("[") && l.endsWith("]")) {
          const c = l.replace("[", "").replace("]", "");
          l = c, i = Object.keys(e.data).filter((p) => p.includes(c)).map(
            (p) => Kn(e.data[p], o, a)
          ).some((p) => p);
        } else
          i = Kn(e.data[l], o, a);
        if (!i)
          break;
      }
      return i;
    };
  }
  set columns(t) {
    const e = [];
    for (const i of t) {
      const n = typeof i == "string" ? { name: i, width: `minmax(${this.minColWidth}, 1fr)` } : i;
      e.push(n);
    }
    this._columns = e, this.computeMissingColumns(this.data), this.dispatchEvent(new Event("columnschange"));
  }
  get columns() {
    return this._columns;
  }
  get _headerRowData() {
    const t = {};
    for (const e of this.columns) {
      const { name: i } = e;
      t[i] = String(i);
    }
    return t;
  }
  /**
   * Getter for the `value` property.
   * Returns the filtered data if a search string is provided, otherwise returns the original data.
   *
   * @example
   * ```typescript
   * const tableValue = table.value;
   * console.log(tableValue); // Output: The filtered or original data.
   * ```
   */
  get value() {
    return this._filteredData;
  }
  /**
   * Sets the search string for filtering the table data.
   * This property allows you to filter the table data based on a search string.
   * If a search string is provided, the table will only display rows that match the search criteria.
   * The search criteria can be a simple string or a complex query.
   * If a simple string is provided, the table will filter rows based on the string's presence in any column.
   * If a complex query is provided, the table will filter rows based on the query's conditions and values.
   *
   * @example Simple Query
   * ```typescript
   * table.queryString = "example";
   * ```
   *
   * @example Complex Query
   * ```typescript
   * table.queryString = "column1="Jhon Doe" & column2=20";
   * ```
   */
  set queryString(t) {
    this.toggleAttribute("data-processing", true), this._queryString = t && t.trim() !== "" ? t.trim() : null, this.updateFilteredData(), this.toggleAttribute("data-processing", false);
  }
  get queryString() {
    return this._queryString;
  }
  set data(t) {
    this._data = t, this.updateFilteredData(), this.computeMissingColumns(t) && (this.columns = this._columns);
  }
  get data() {
    return this._data;
  }
  get dataAsync() {
    return new Promise((t) => {
      setTimeout(() => {
        t(this.data);
      });
    });
  }
  set hiddenColumns(t) {
    this._hiddenColumns = t, setTimeout(() => {
      this.dispatchEvent(this._onColumnsHidden);
    });
  }
  get hiddenColumns() {
    return this._hiddenColumns;
  }
  updateFilteredData() {
    this.queryString ? (yi(this.queryString) ? (this.filterFunction = this._queryFilterFunction, this._filteredData = this.filter(this.queryString)) : (this.filterFunction = this._stringFilterFunction, this._filteredData = this.filter(this.queryString)), this.preserveStructureOnFilter && (this._expandedBeforeFilter === void 0 && (this._expandedBeforeFilter = this.expanded), this.expanded = true)) : (this.preserveStructureOnFilter && this._expandedBeforeFilter !== void 0 && (this.expanded = this._expandedBeforeFilter, this._expandedBeforeFilter = void 0), this._filteredData = this.data);
  }
  computeMissingColumns(t) {
    let e = false;
    for (const i of t) {
      const { children: n, data: r } = i;
      for (const o in r)
        this._columns.map((l) => typeof l == "string" ? l : l.name).includes(o) || (this._columns.push({
          name: o,
          width: `minmax(${this.minColWidth}, 1fr)`
        }), e = true);
      if (n) {
        const o = this.computeMissingColumns(n);
        o && !e && (e = o);
      }
    }
    return e;
  }
  generateText(t = "comma", e = this.value, i = "", n = true) {
    const r = this._textDelimiters[t];
    let o = "";
    const a = this.columns.map((l) => l.name);
    if (n) {
      this.indentationInText && (o += `Indentation${r}`);
      const l = `${a.join(r)}
`;
      o += l;
    }
    for (const [l, c] of e.entries()) {
      const { data: u, children: h } = c, p = this.indentationInText ? `${i}${l + 1}${r}` : "", m = a.map((v) => u[v] ?? ""), g = `${p}${m.join(r)}
`;
      o += g, h && (o += this.generateText(
        t,
        c.children,
        `${i}${l + 1}.`,
        false
      ));
    }
    return o;
  }
  /**
   * A getter function that generates a CSV (Comma Separated Values) representation of the table data.
   *
   * @returns A string containing the CSV representation of the table data.
   *
   * @example
   * ```typescript
   * const csvData = table.csv;
   * console.log(csvData); // Output: "Column 1,Column 2\nValue 1,Value 2\nValue 3,Value 4"
   * ```
   */
  get csv() {
    return this.generateText("comma");
  }
  /**
   * A getter function that generates a Tab Separated Values (TSV) representation of the table data.
   *
   * @returns A string containing the TSV representation of the table data.
   *
   * @example
   * ```typescript
   * const tsvData = table.tsv;
   * console.log(tsvData); // Output: "Column 1\tColumn 2\nValue 1\tValue 2\nValue 3\tValue 4"
   * ```
   */
  get tsv() {
    return this.generateText("tab");
  }
  applyDataTransform(t) {
    const e = {};
    if (!t)
      return e;
    const { data: i } = t.data;
    for (const r of Object.keys(this.dataTransform)) {
      const o = this.columns.find((a) => a.name === r);
      o && o.forceDataTransform && (r in i || (i[r] = ""));
    }
    const n = i;
    for (const r in n) {
      const o = this.dataTransform[r];
      o ? e[r] = o(n[r], i, t) : e[r] = i[r];
    }
    return e;
  }
  /**
   * The `downloadData` method is used to download the table data in different formats.
   *
   * @param fileName - The name of the downloaded file. Default is "BIM Table Data".
   * @param format - The format of the downloaded file. Can be "json", "tsv", or "csv". Default is "json".
   *
   * @returns - This method does not return any value.
   *
   * @example
   * ```typescript
   * table.downloadData("MyTableData", "tsv");
   * ```
   */
  downloadData(t = "BIM Table Data", e = "json") {
    let i = null;
    if (e === "json" && (i = new File(
      [JSON.stringify(this.value, void 0, 2)],
      `${t}.json`
    )), e === "csv" && (i = new File([this.csv], `${t}.csv`)), e === "tsv" && (i = new File([this.tsv], `${t}.tsv`)), !i)
      return;
    const n = document.createElement("a");
    n.href = URL.createObjectURL(i), n.download = i.name, n.click(), URL.revokeObjectURL(n.href);
  }
  getRowIndentation(t, e = this.value, i = 0) {
    for (const n of e) {
      if (n.data === t)
        return i;
      if (n.children) {
        const r = this.getRowIndentation(
          t,
          n.children,
          i + 1
        );
        if (r !== null)
          return r;
      }
    }
    return null;
  }
  getGroupIndentation(t, e = this.value, i = 0) {
    for (const n of e) {
      if (n === t)
        return i;
      if (n.children) {
        const r = this.getGroupIndentation(
          t,
          n.children,
          i + 1
        );
        if (r !== null)
          return r;
      }
    }
    return null;
  }
  connectedCallback() {
    super.connectedCallback(), this.dispatchEvent(new Event("connected"));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.dispatchEvent(new Event("disconnected"));
  }
  /**
   * Asynchronously loads data into the table based on Table.loadFunction.
   * If the data is already available, just set it in Table.data.
   *
   * @param force - A boolean indicating whether to force loading even if the table already has data.
   *
   * @returns - A promise that resolves to a boolean indicating whether the data loading was successful.
   * If the promise resolves to `true`, the data loading was successful.
   * If the promise resolves to `false`, the data loading was not successful.
   *
   * @remarks - If the table already has data and `force` is `false`, the function resolves to `false` without making any changes.
   * If the table already has data and `force` is `true`, the existing data is discarded before loading the new data.
   * If an error occurs during data loading, the function sets the `errorLoadingMessage` property with the error message and resolves to `false`.
   */
  async loadData(t = false) {
    if (this._filteredData.length !== 0 && !t || !this.loadFunction)
      return false;
    this.loading = true;
    try {
      const e = await this.loadFunction();
      return this.data = e, this.loading = false, this._errorLoading = false, true;
    } catch (e) {
      if (this.loading = false, this._filteredData.length !== 0)
        return false;
      const i = this.querySelector("[slot='error-loading']"), n = i == null ? void 0 : i.querySelector(
        "[data-table-element='error-message']"
      );
      return e instanceof Error && n && e.message.trim() !== "" && (n.textContent = e.message), this._errorLoading = true, false;
    }
  }
  filter(t, e = this.filterFunction ?? this._stringFilterFunction, i = this.data) {
    const n = [];
    for (const r of i)
      if (e(t, r)) {
        if (this.preserveStructureOnFilter) {
          const a = { data: r.data };
          if (r.children) {
            const l = this.filter(
              t,
              e,
              r.children
            );
            l.length && (a.children = l);
          }
          n.push(a);
        } else if (n.push({ data: r.data }), r.children) {
          const a = this.filter(
            t,
            e,
            r.children
          );
          n.push(...a);
        }
      } else if (r.children) {
        const a = this.filter(
          t,
          e,
          r.children
        );
        this.preserveStructureOnFilter && a.length ? n.push({
          data: r.data,
          children: a
        }) : n.push(...a);
      }
    return n;
  }
  get _missingDataElement() {
    return this.querySelector("[slot='missing-data']");
  }
  render() {
    if (this.loading)
      return qa();
    if (this._errorLoading)
      return f`<slot name="error-loading"></slot>`;
    if (this._filteredData.length === 0 && this._missingDataElement)
      return f`<slot name="missing-data"></slot>`;
    const t = (i) => {
      if (!i)
        return;
      const n = i;
      n.table = this, n.data = this._headerRowData;
    }, e = (i) => {
      if (!i)
        return;
      const n = i;
      n.table = this, n.data = this.value, n.requestUpdate();
    };
    return f`
      <div class="parent">
        ${Va()}
        ${Dt(!this.headersHidden, () => f`<bim-table-row is-header style="grid-area: Header; position: sticky; top: 0; z-index: 5" ${J(t)}></bim-table-row>`)} 
        <div style="overflow-x: hidden; grid-area: Body">
          <bim-table-children ${J(e)} style="grid-area: Body; background-color: transparent"></bim-table-children>
        </div>
      </div>
    `;
  }
};
rn.styles = [
  xt.scrollbar,
  S`
      :host {
        position: relative;
        overflow: auto;
        display: block;
        pointer-events: auto;
      }

      :host(:not([data-processing])) .loader {
        display: none;
      }

      .parent {
        display: grid;
        grid-template:
          "Header" auto
          "Processing" auto
          "Body" 1fr
          "Footer" auto;
        overflow: auto;
        height: 100%;
      }

      .parent > bim-table-row[is-header] {
        color: var(--bim-table_header--c, var(--bim-ui_bg-contrast-100));
        background-color: var(
          --bim-table_header--bgc,
          var(--bim-ui_bg-contrast-20)
        );
      }

      .controls {
        display: flex;
        gap: 0.375rem;
        flex-wrap: wrap;
        margin-bottom: 0.5rem;
      }
    `
];
var B = rn;
V([
  Lt()
], B.prototype, "_filteredData", 2);
V([
  d({
    type: Boolean,
    attribute: "headers-hidden",
    reflect: true
  })
], B.prototype, "headersHidden", 2);
V([
  d({ type: String, attribute: "min-col-width", reflect: true })
], B.prototype, "minColWidth", 2);
V([
  d({ type: Array, attribute: false })
], B.prototype, "columns", 1);
V([
  d({ type: Array, attribute: false })
], B.prototype, "data", 1);
V([
  d({ type: Boolean, reflect: true })
], B.prototype, "expanded", 2);
V([
  d({ type: Boolean, reflect: true, attribute: "selectable-rows" })
], B.prototype, "selectableRows", 2);
V([
  d({ attribute: false })
], B.prototype, "selection", 2);
V([
  d({ type: Boolean, attribute: "no-indentation", reflect: true })
], B.prototype, "noIndentation", 2);
V([
  d({ type: Boolean, attribute: "no-carets", reflect: true })
], B.prototype, "noCarets", 2);
V([
  d({ type: Boolean, reflect: true })
], B.prototype, "loading", 2);
V([
  Lt()
], B.prototype, "_errorLoading", 2);
var Ja = Object.defineProperty;
var tl = Object.getOwnPropertyDescriptor;
var Qt = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? tl(t, e) : t, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (n = (i ? o(t, e, n) : o(n)) || n);
  return i && n && Ja(t, e, n), n;
};
var on = class on2 extends C {
  constructor() {
    super(...arguments), this._switchers = [], this.bottom = false, this.switchersHidden = false, this.floating = false, this.switchersFull = false, this.onTabHiddenChange = (t) => {
      const e = t.target;
      e instanceof R && !e.hidden && (e.removeEventListener("hiddenchange", this.onTabHiddenChange), this.tab = e.name, e.addEventListener("hiddenchange", this.onTabHiddenChange));
    };
  }
  set tab(t) {
    this._tab = t;
    const e = [...this.children], i = e.find(
      (n) => n instanceof R && n.name === t
    );
    for (const n of e) {
      if (!(n instanceof R))
        continue;
      n.hidden = i !== n;
      const r = this.getTabSwitcher(n.name);
      r && r.toggleAttribute("data-active", !n.hidden);
    }
    i || (this._tab = "hidden", this.setAttribute("tab", "hidden"));
  }
  get tab() {
    return this._tab;
  }
  getTabSwitcher(t) {
    return this._switchers.find(
      (i) => i.getAttribute("data-name") === t
    );
  }
  createSwitchers() {
    this._switchers = [];
    for (const t of this.children) {
      if (!(t instanceof R))
        continue;
      const e = document.createElement("div");
      e.addEventListener("click", () => {
        this.tab === t.name ? this.toggleAttribute("tab", false) : this.tab = t.name, this.setAnimatedBackgound();
      }), e.setAttribute("data-name", t.name), e.className = "switcher";
      const i = document.createElement("bim-label");
      i.textContent = t.label ?? null, i.icon = t.icon, e.append(i), this._switchers.push(e);
    }
  }
  updateSwitchers() {
    for (const t of this.children) {
      if (!(t instanceof R))
        continue;
      const e = this._switchers.find(
        (n) => n.getAttribute("data-name") === t.name
      );
      if (!e)
        continue;
      const i = e.querySelector("bim-label");
      i && (i.textContent = t.label ?? null, i.icon = t.icon);
    }
  }
  onSlotChange(t) {
    this.createSwitchers();
    const e = t.target.assignedElements(), i = e.find((n) => n instanceof R ? this.tab ? n.name === this.tab : !n.hidden : false);
    i && i instanceof R && (this.tab = i.name);
    for (const n of e) {
      if (!(n instanceof R)) {
        n.remove();
        continue;
      }
      n.removeEventListener("hiddenchange", this.onTabHiddenChange), i !== n && (n.hidden = true), n.addEventListener("hiddenchange", this.onTabHiddenChange);
    }
  }
  doubleRequestAnimationFrames(t) {
    requestAnimationFrame(() => requestAnimationFrame(t));
  }
  setAnimatedBackgound(t = false) {
    var n;
    const e = this.renderRoot.querySelector(
      ".animated-background"
    ), i = [
      ...((n = this.renderRoot.querySelector(".switchers")) == null ? void 0 : n.querySelectorAll(".switcher")) || []
    ].filter((r) => r.hasAttribute("data-active"))[0];
    requestAnimationFrame(() => {
      var a, l, c, u;
      const r = (u = (c = (l = (a = i == null ? void 0 : i.parentElement) == null ? void 0 : a.shadowRoot) == null ? void 0 : l.querySelector("bim-input")) == null ? void 0 : c.shadowRoot) == null ? void 0 : u.querySelector(".input"), o = {
        width: i == null ? void 0 : i.clientWidth,
        height: i == null ? void 0 : i.clientHeight,
        top: ((i == null ? void 0 : i.offsetTop) ?? 0) - ((r == null ? void 0 : r.offsetTop) ?? 0),
        left: ((i == null ? void 0 : i.offsetLeft) ?? 0) - ((r == null ? void 0 : r.offsetLeft) ?? 0)
      };
      i ? (e == null || e.style.setProperty("width", `${o.width}px`), e == null || e.style.setProperty("height", `${o.height}px`), e == null || e.style.setProperty("left", `${o.left}px`)) : e == null || e.style.setProperty("width", "0"), this.bottom ? (e == null || e.style.setProperty("top", "100%"), e == null || e.style.setProperty("transform", "translateY(-100%)")) : e == null || e.style.setProperty("top", `${o.top}px`);
    }), t && this.doubleRequestAnimationFrames(() => {
      const o = "ease";
      e == null || e.style.setProperty(
        "transition",
        `width ${0.3}s ${o}, height ${0.3}s ${o}, top ${0.3}s ${o}, left ${0.3}s ${o}`
      );
    });
  }
  firstUpdated() {
    requestAnimationFrame(() => {
      this.setAnimatedBackgound(true);
    }), new ResizeObserver(() => {
      this.setAnimatedBackgound();
    }).observe(this);
  }
  render() {
    return f`
      <div class="parent">
        <div class="switchers">
          <div class="animated-background"></div>
          ${this._switchers}
        </div>
        <div class="content">
          <slot @slotchange=${this.onSlotChange}></slot>
        </div>
      </div>
    `;
  }
};
on.styles = [
  xt.scrollbar,
  S`
      * {
        box-sizing: border-box;
      }

      :host {
        background-color: var(--bim-ui_bg-base);
        display: block;
        overflow: auto;
      }

      .parent {
        display: grid;
        overflow: hidden;
        position: relative;
        grid-template: "switchers" auto "content" 1fr;
        height: 100%;
      }

      :host([bottom]) .parent {
        grid-template: "content" 1fr "switchers" auto;
      }

      .switchers {
        position: relative;
        display: flex;
        height: 2.25rem;
        font-weight: 600;
        grid-area: switchers;
      }

      .switcher {
        --bim-label--c: var(--bim-ui_bg-contrast-80);
        background-color: transparent;
        position: relative;
        cursor: pointer;
        pointer-events: auto;
        padding: 0rem 0.75rem;
        display: flex;
        justify-content: center;
        z-index: 2;
        transition: all 0.15s;
      }

      .switcher:not([data-active]):hover {
        filter: brightness(150%);
      }

      :host([switchers-full]) .switcher {
        flex: 1;
      }

      .switcher[data-active] {
        --bim-label--c: var(--bim-ui_main-contrast);
      }

      .switchers bim-label {
        pointer-events: none;
      }

      :host([switchers-hidden]) .switchers {
        display: none;
      }

      .content {
        position: relative;
        display: grid;
        grid-template-columns: 1fr;
        grid-area: content;
        max-height: 100vh;
        overflow: auto;
        transition: max-height 0.2s;
      }

      :host([tab="hidden"]) .content {
        max-height: 0;
      }

      .animated-background {
        position: absolute;
        background: var(--bim-ui_main-base);
        width: 0;
        height: 0;
        top: 0;
        left: 0;
      }

      :host(:not([bottom])) .content {
        border-top: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([bottom]) .content {
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating]) {
        background-color: transparent;
      }

      :host([floating]) .switchers {
        justify-self: center;
        overflow: hidden;
        background-color: var(--bim-ui_bg-base);
      }

      :host([floating]:not([bottom])) .switchers {
        border-radius: var(--bim-ui_size-2xs) var(--bim-ui_size-2xs) 0 0;
        border-top: 1px solid var(--bim-ui_bg-contrast-20);
        border-left: 1px solid var(--bim-ui_bg-contrast-20);
        border-right: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating][bottom]) .switchers {
        border-radius: 0 0 var(--bim-ui_size-2xs) var(--bim-ui_size-2xs);
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
        border-left: 1px solid var(--bim-ui_bg-contrast-20);
        border-right: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating][tab="hidden"]) .switchers {
        border-radius: var(--bim-ui_size-2xs);
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating][bottom][tab="hidden"]) .switchers {
        border-top: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating]) .content {
        border: 1px solid var(--bim-ui_bg-contrast-20);
        border-radius: var(--bim-ui_size-2xs);
        background-color: var(--bim-ui_bg-base);
      }
    `
];
var Y = on;
Qt([
  Lt()
], Y.prototype, "_switchers", 2);
Qt([
  d({ type: Boolean, reflect: true })
], Y.prototype, "bottom", 2);
Qt([
  d({ type: Boolean, attribute: "switchers-hidden", reflect: true })
], Y.prototype, "switchersHidden", 2);
Qt([
  d({ type: Boolean, reflect: true })
], Y.prototype, "floating", 2);
Qt([
  d({ type: String, reflect: true })
], Y.prototype, "tab", 1);
Qt([
  d({ type: Boolean, attribute: "switchers-full", reflect: true })
], Y.prototype, "switchersFull", 2);
var el = Object.defineProperty;
var il = Object.getOwnPropertyDescriptor;
var Ke = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? il(t, e) : t, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (n = (i ? o(t, e, n) : o(n)) || n);
  return i && n && el(t, e, n), n;
};
var an = class an2 extends C {
  constructor() {
    super(...arguments), this._defaultName = "__unnamed__", this.name = this._defaultName, this._hidden = false;
  }
  set label(t) {
    this._label = t;
    const e = this.parentElement;
    e instanceof Y && e.updateSwitchers();
  }
  get label() {
    return this._label;
  }
  set icon(t) {
    this._icon = t;
    const e = this.parentElement;
    e instanceof Y && e.updateSwitchers();
  }
  get icon() {
    return this._icon;
  }
  set hidden(t) {
    this._hidden = t, this.dispatchEvent(new Event("hiddenchange"));
  }
  get hidden() {
    return this._hidden;
  }
  connectedCallback() {
    super.connectedCallback();
    const { parentElement: t } = this;
    if (t && this.name === this._defaultName) {
      const e = [...t.children].indexOf(this);
      this.name = `${this._defaultName}${e}`;
    }
  }
  render() {
    return f` <slot></slot> `;
  }
};
an.styles = S`
    :host {
      display: block;
      height: 100%;
      grid-row-start: 1;
      grid-column-start: 1;
      animation: openAnim 3s forwards;
      transform: translateY(0);
      max-height: 100vh;
      transition:
        opacity 0.3s ease,
        max-height 0.6s ease,
        transform 0.3s ease;
    }

    :host([hidden]) {
      transform: translateY(-20px);
      max-height: 0;
      opacity: 0;
      overflow: hidden;
      visibility: hidden;
    }
  `;
var R = an;
Ke([
  d({ type: String, reflect: true })
], R.prototype, "name", 2);
Ke([
  d({ type: String, reflect: true })
], R.prototype, "label", 1);
Ke([
  d({ type: String, reflect: true })
], R.prototype, "icon", 1);
Ke([
  d({ type: Boolean, reflect: true })
], R.prototype, "hidden", 1);
var nl = Object.defineProperty;
var sl = Object.getOwnPropertyDescriptor;
var Q = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? sl(t, e) : t, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (n = (i ? o(t, e, n) : o(n)) || n);
  return i && n && nl(t, e, n), n;
};
var ln = class ln2 extends C {
  constructor() {
    super(...arguments), this._inputTypes = [
      "date",
      "datetime-local",
      "email",
      "month",
      "password",
      "search",
      "tel",
      "text",
      "time",
      "url",
      "week",
      "area"
    ], this.value = "", this.vertical = false, this.disabled = false, this.resize = "vertical", this._type = "text", this.onValueChange = new Event("input");
  }
  set type(t) {
    this._inputTypes.includes(t) && (this._type = t);
  }
  get type() {
    return this._type;
  }
  /**
   * Gets the query value derived from the current input value.
   * The `getQuery` function is assumed to be a utility function that takes a string as input
   * and returns a processed query value based on the input.
   *
   * @returns The processed query value derived from the current input value.
   *
   * @example
   * ```typescript
   * const textInput = new TextInput();
   * textInput.value = "Key?Value";
   * console.log(textInput.query);
   * ```
   */
  get query() {
    return yi(this.value);
  }
  onInputChange(t) {
    t.stopPropagation();
    const e = t.target;
    clearTimeout(this._debounceTimeoutID), this._debounceTimeoutID = setTimeout(() => {
      this.value = e.value, this.dispatchEvent(this.onValueChange);
    }, this.debounce);
  }
  focus() {
    setTimeout(() => {
      var e;
      const t = (e = this.shadowRoot) == null ? void 0 : e.querySelector("input");
      t == null || t.focus();
    });
  }
  render() {
    return f`
      <bim-input
        .name=${this.name}
        .icon=${this.icon}
        .label=${this.label}
        .vertical=${this.vertical}
      >
        ${this.type === "area" ? f` <textarea
              aria-label=${this.label || this.name || "Text Input"}
              .value=${this.value}
              .rows=${this.rows ?? 5}
              ?disabled=${this.disabled}
              placeholder=${wi(this.placeholder)}
              @input=${this.onInputChange}
              style="resize: ${this.resize};"
            ></textarea>` : f` <input
              aria-label=${this.label || this.name || "Text Input"}
              .type=${this.type}
              .value=${this.value}
              ?disabled=${this.disabled}
              placeholder=${wi(this.placeholder)}
              @input=${this.onInputChange}
            />`}
      </bim-input>
    `;
  }
};
ln.styles = [
  xt.scrollbar,
  S`
      :host {
        --bim-input--bgc: var(--bim-ui_bg-contrast-20);
        flex: 1;
        display: block;
      }

      input,
      textarea {
        font-family: inherit;
        background-color: transparent;
        border: none;
        width: 100%;
        padding: var(--bim-ui_size-3xs);
        color: var(--bim-text-input--c, var(--bim-ui_bg-contrast-100));
      }

      input {
        outline: none;
        height: 100%;
        padding: 0 var(--bim-ui_size-3xs); /* Override padding */
        border-radius: var(--bim-text-input--bdrs, var(--bim-ui_size-4xs));
      }

      :host([disabled]) input,
      :host([disabled]) textarea {
        color: var(--bim-ui_bg-contrast-60);
      }

      textarea {
        line-height: 1.1rem;
        outline: none;
      }

      :host(:focus) {
        --bim-input--olc: var(--bim-ui_accent-base);
      }

      /* :host([disabled]) {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
    } */
    `
];
var M = ln;
Q([
  d({ type: String, reflect: true })
], M.prototype, "icon", 2);
Q([
  d({ type: String, reflect: true })
], M.prototype, "label", 2);
Q([
  d({ type: String, reflect: true })
], M.prototype, "name", 2);
Q([
  d({ type: String, reflect: true })
], M.prototype, "placeholder", 2);
Q([
  d({ type: String, reflect: true })
], M.prototype, "value", 2);
Q([
  d({ type: Boolean, reflect: true })
], M.prototype, "vertical", 2);
Q([
  d({ type: Number, reflect: true })
], M.prototype, "debounce", 2);
Q([
  d({ type: Number, reflect: true })
], M.prototype, "rows", 2);
Q([
  d({ type: Boolean, reflect: true })
], M.prototype, "disabled", 2);
Q([
  d({ type: String, reflect: true })
], M.prototype, "resize", 2);
Q([
  d({ type: String, reflect: true })
], M.prototype, "type", 1);
var rl = Object.defineProperty;
var ol = Object.getOwnPropertyDescriptor;
var Qs = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? ol(t, e) : t, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (n = (i ? o(t, e, n) : o(n)) || n);
  return i && n && rl(t, e, n), n;
};
var cn = class cn2 extends C {
  constructor() {
    super(...arguments), this.rows = 2, this._vertical = false;
  }
  set vertical(t) {
    this._vertical = t, this.updateChildren();
  }
  get vertical() {
    return this._vertical;
  }
  updateChildren() {
    const t = this.children;
    for (const e of t)
      this.vertical ? e.setAttribute("label-hidden", "") : e.removeAttribute("label-hidden");
  }
  render() {
    return f`
      <style>
        .parent {
          grid-auto-flow: ${this.vertical ? "row" : "column"};
          grid-template-rows: repeat(${this.rows}, 1fr);
        }
      </style>
      <div class="parent">
        <slot @slotchange=${this.updateChildren}></slot>
      </div>
    `;
  }
};
cn.styles = S`
    .parent {
      display: grid;
      gap: 0.25rem;
    }

    ::slotted(bim-button[label]:not([vertical])) {
      --bim-button--jc: flex-start;
    }

    ::slotted(bim-button) {
      --bim-label--c: var(--bim-ui_bg-contrast-80);
    }
  `;
var Wt = cn;
Qs([
  d({ type: Number, reflect: true })
], Wt.prototype, "rows", 2);
Qs([
  d({ type: Boolean, reflect: true })
], Wt.prototype, "vertical", 1);
var al = Object.defineProperty;
var ll = Object.getOwnPropertyDescriptor;
var Xe = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? ll(t, e) : t, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (n = (i ? o(t, e, n) : o(n)) || n);
  return i && n && al(t, e, n), n;
};
var un = class un2 extends C {
  constructor() {
    super(...arguments), this._vertical = false, this._labelHidden = false;
  }
  set vertical(t) {
    this._vertical = t, this.updateChildren();
  }
  get vertical() {
    return this._vertical;
  }
  set labelHidden(t) {
    this._labelHidden = t, this.updateChildren();
  }
  get labelHidden() {
    return this._labelHidden;
  }
  updateChildren() {
    const t = this.children;
    for (const e of t)
      e instanceof Wt && (e.vertical = this.vertical), e.toggleAttribute("label-hidden", this.vertical);
  }
  render() {
    return f`
      <div class="parent">
        <div class="children">
          <slot @slotchange=${this.updateChildren}></slot>
        </div>
        ${!this.labelHidden && (this.label || this.icon) ? f`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
      </div>
    `;
  }
};
un.styles = S`
    :host {
      --bim-label--fz: var(--bim-ui_size-xs);
      --bim-label--c: var(--bim-ui_bg-contrast-60);
      display: block;
      flex: 1;
    }

    :host(:not([vertical])) ::slotted(bim-button[vertical]) {
      --bim-icon--fz: var(--bim-ui_size-5xl);
      min-height: 3.75rem;
    }

    .parent {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      align-items: center;
      padding: 0.5rem;
      height: 100%;
      box-sizing: border-box;
      justify-content: space-between;
    }

    :host([vertical]) .parent {
      flex-direction: row-reverse;
    }

    :host([vertical]) .parent > bim-label {
      writing-mode: tb;
    }

    .children {
      display: flex;
      gap: 0.25rem;
    }

    :host([vertical]) .children {
      flex-direction: column;
    }
  `;
var _t = un;
Xe([
  d({ type: String, reflect: true })
], _t.prototype, "label", 2);
Xe([
  d({ type: String, reflect: true })
], _t.prototype, "icon", 2);
Xe([
  d({ type: Boolean, reflect: true })
], _t.prototype, "vertical", 1);
Xe([
  d({ type: Boolean, attribute: "label-hidden", reflect: true })
], _t.prototype, "labelHidden", 1);
var cl = Object.defineProperty;
var ul = Object.getOwnPropertyDescriptor;
var Fi = (s, t, e, i) => {
  for (var n = i > 1 ? void 0 : i ? ul(t, e) : t, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (n = (i ? o(t, e, n) : o(n)) || n);
  return i && n && cl(t, e, n), n;
};
var hn = class hn2 extends C {
  constructor() {
    super(...arguments), this.labelsHidden = false, this._vertical = false, this._hidden = false;
  }
  set vertical(t) {
    this._vertical = t, this.updateSections();
  }
  get vertical() {
    return this._vertical;
  }
  set hidden(t) {
    this._hidden = t, this.dispatchEvent(new Event("hiddenchange"));
  }
  get hidden() {
    return this._hidden;
  }
  // private setActivationButton() {
  //   this.activationButton.draggable = Manager.config.draggableToolbars;
  //   this.activationButton.addEventListener(
  //     "click",
  //     () => (this.hidden = !this.hidden),
  //   );
  //   this.activationButton.setAttribute("data-ui-manager-id", this._managerID);
  //   this.activationButton.addEventListener("dragstart", (e) => {
  //     const id = this.getAttribute("data-ui-manager-id");
  //     if (e.dataTransfer && id) {
  //       e.dataTransfer.setData("id", id);
  //       e.dataTransfer.effectAllowed = "move";
  //     }
  //     const containers = document.querySelectorAll("bim-toolbars-container");
  //     for (const container of containers) {
  //       if (container === this.parentElement) continue;
  //       container.dropping = true;
  //     }
  //   });
  //   this.activationButton.addEventListener("dragend", (e) => {
  //     if (e.dataTransfer) e.dataTransfer.clearData();
  //     const containers = document.querySelectorAll("bim-toolbars-container");
  //     for (const container of containers) {
  //       container.dropping = false;
  //     }
  //   });
  // }
  updateSections() {
    const t = this.children;
    for (const e of t)
      e instanceof _t && (e.labelHidden = this.vertical && !he.config.sectionLabelOnVerticalToolbar, e.vertical = this.vertical);
  }
  // firstUpdated() {
  //   this.setAttribute("data-ui-manager-id", this._managerID);
  // }
  render() {
    return f`
      <div class="parent">
        <slot @slotchange=${this.updateSections}></slot>
      </div>
    `;
  }
};
hn.styles = S`
    :host {
      --bim-button--bgc: transparent;
      background-color: var(--bim-ui_bg-base);
      border-radius: var(--bim-ui_size-2xs);
      display: block;
    }

    :host([hidden]) {
      display: none;
    }

    .parent {
      display: flex;
      width: max-content;
      pointer-events: auto;
    }

    :host([vertical]) .parent {
      flex-direction: column;
    }

    :host([vertical]) {
      width: min-content;
      border-radius: var(--bim-ui_size-2xs);
      border: 1px solid var(--bim-ui_bg-contrast-20);
    }

    ::slotted(bim-toolbar-section:not(:last-child)) {
      border-right: 1px solid var(--bim-ui_bg-contrast-20);
      border-bottom: none;
    }

    :host([vertical]) ::slotted(bim-toolbar-section:not(:last-child)) {
      border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      border-right: none;
    }
  `;
var Yt = hn;
Fi([
  d({ type: String, reflect: true })
], Yt.prototype, "icon", 2);
Fi([
  d({ type: Boolean, attribute: "labels-hidden", reflect: true })
], Yt.prototype, "labelsHidden", 2);
Fi([
  d({ type: Boolean, reflect: true })
], Yt.prototype, "vertical", 1);
var hl = Object.defineProperty;
var dl = (s, t, e, i) => {
  for (var n = void 0, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (n = o(t, e, n) || n);
  return n && hl(t, e, n), n;
};
var dn = class dn2 extends C {
  constructor() {
    super(), this._onResize = new Event("resize"), new ResizeObserver(() => {
      setTimeout(() => {
        this.dispatchEvent(this._onResize);
      });
    }).observe(this);
  }
  render() {
    return f`
      <div class="parent">
        <slot></slot>
      </div>
    `;
  }
};
dn.styles = S`
    :host {
      display: grid;
      min-width: 0;
      min-height: 0;
      height: 100%;
    }

    .parent {
      overflow: hidden;
      position: relative;
    }
  `;
var De = dn;
dl([
  d({ type: String, reflect: true })
], De.prototype, "name");
var pl = Object.defineProperty;
var Ni = (s, t, e, i) => {
  for (var n = void 0, r = s.length - 1, o; r >= 0; r--)
    (o = s[r]) && (n = o(t, e, n) || n);
  return n && pl(t, e, n), n;
};
var I;
var Ze = (I = class extends C {
  constructor() {
    super(...arguments), this.visible = false, this._previousContainer = null, this._showToolTip = async () => {
      this.timeoutId = setTimeout(async () => {
        if (this.visible = true, !I.container.parentElement) {
          const t = document.querySelector("[data-context-dialog]");
          t ? t.append(I.container) : document.body.append(I.container);
        }
        this._previousContainer = this.parentElement, I.container.style.top = `${window.scrollY || document.documentElement.scrollTop}px`, I.container.append(this), await this.computePosition();
      }, this.timeout === void 0 ? 800 : this.timeout);
    }, this._hideToolTip = () => {
      clearTimeout(this.timeoutId), this.visible = false, this._previousContainer && (this._previousContainer.append(this), this._previousContainer = null), I.container.children.length === 0 && I.container.parentElement && I.container.remove();
    };
  }
  static get container() {
    return I._container || (I._container = document.createElement("div"), I._container.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 0;
        height: 0;
        overflow: visible;
        pointer-events: none;
        z-index: 9999;
      `), I._container;
  }
  async computePosition() {
    const t = this._previousContainer || this.parentElement;
    if (!t)
      return;
    const e = this.style.display;
    this.style.display = "block", this.style.visibility = "hidden", await new Promise(requestAnimationFrame);
    const { x: i, y: n } = await Pi(t, this, {
      placement: this.placement,
      middleware: [$i(10), Ei(), Si({ padding: 8 }), ki()]
    });
    Object.assign(this.style, {
      left: `${i}px`,
      top: `${n}px`,
      display: e,
      visibility: ""
    });
  }
  connectedCallback() {
    super.connectedCallback();
    const t = this.parentElement;
    t && (t.addEventListener("mouseenter", this._showToolTip), t.addEventListener("mouseleave", this._hideToolTip));
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    const t = this.parentElement;
    t && (t.removeEventListener("mouseenter", this._showToolTip), t.removeEventListener("mouseleave", this._hideToolTip));
  }
  render() {
    return f`<div><slot></slot></div>`;
  }
}, I.styles = S`
    :host {
      position: absolute;
      background: var(--bim-ui_bg-contrast-20, #fff);
      color: var(--bim-ui_bg-contrast-100, #000);
      border-radius: var(--bim-ui_size-4xs, 4px);
      box-shadow: 0 0 10px 3px rgba(0, 0, 0, 0.2);
      padding: 0.75rem;
      font-size: var(--bim-ui_size-xs, 0.875rem);
      display: none;
    }
    :host([visible]) {
      display: flex;
    }
  `, I._container = null, I);
Ni([
  d({ type: Boolean, reflect: true })
], Ze.prototype, "visible");
Ni([
  d({ type: Number, reflect: true })
], Ze.prototype, "timeout");
Ni([
  d({ type: String, reflect: true })
], Ze.prototype, "placement");
var fl = Ze;
export {
  Ea as Button,
  bt as Checkbox,
  tt as ColorInput,
  Ut as Component,
  Ee as ContextMenu,
  H as Dropdown,
  de as Grid,
  _i as Icon,
  It as Input,
  gt as Label,
  he as Manager,
  z as NumberInput,
  T as Option,
  ot as Panel,
  vt as PanelSection,
  yt as Selector,
  R as Tab,
  B as Table,
  Me as TableCell,
  xi as TableChildren,
  je as TableGroup,
  at as TableRow,
  Y as Tabs,
  M as TextInput,
  Yt as Toolbar,
  Wt as ToolbarGroup,
  _t as ToolbarSection,
  fl as Tooltip,
  De as Viewport,
  Be as getElementValue,
  f as html,
  J as ref,
  Xn as styleMap
};
//# sourceMappingURL=@thatopen_ui.js.map
